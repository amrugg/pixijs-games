<html>
  <head>
    <link href="favicon.png" type="image/png" rel="icon">
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ship Shooter</title>
</head>
    <style>* {padding: 0; margin: 0}</style>
    <script src="pixi/pixi.min.js"></script>
    <script src="usefulFunctions.js"></script>
    <script src ="bump.js"></script>
<body>
  <script type="text/javascript">
    var BUMP = new Bump(PIXI);
    var params = getParams();
    function getParams() {
      var params = {};
      location.search.substr(1).split("&").forEach(function(el) {
        var data = el.replace(/\+/g, " ").split("=");
        params[decodeURIComponent(data[0])] = data[1] ? decodeURIComponent(data[1]) : true;
      });
      return params;
    }
    var debug = params.debug || false;
    PIXI.utils.skipHello();
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
    let Application = PIXI.Application,
        Container = PIXI.Container,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        TextureCache = PIXI.utils.TextureCache,
        Sprite = PIXI.Sprite,
        Rectangle = PIXI.Rectangle,
        Graphics = PIXI.Graphics;
    let app = new Application({ 
        width: 800,
        height: 800,              
        antialias: true,
        transparent: false,
        resolution: 1
      }
    );
    /// Fill the screen 
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    app.renderer.autoResize = true;
    app.renderer.resize(window.innerWidth, window.innerHeight);
    document.body.appendChild(app.view);
    gameScene = new Container();
    var gameScene;
    app.stage.addChild(gameScene);
    var fireCannon = false;
    var files = ["pirateshipblackhurt","pirateshipblackhurt2","pirateshipblackhurt3","cannonball","island","pirateBlob","pirateshipblack","pirateshipred","topDownShip","topDownShipdeath","topDownShiphurt","topDownShiphurt2","topDownShiphurt3"]
    loadArray(files, "sprites", "png");
    loader.add("sprites/treasureHunter.json").load(setup);
    var ship, windSpeed, windDirection;
    var pirateShips = [];
    var cannonballSpeed = 10;
    var cannonballs = 41;
    var HUD = new PIXI.Text("Cannonballs: " + cannonballs.toString() + " Health: " + (10).toString());
    HUD.x = 1000;
    gameScene.addChild(HUD);
    var globalX = 0;
    var globalY = 0;
    var explorer;
    var id, introScene;
    var wPress, sPress;
    function setup() {
      id = resources["sprites/treasureHunter.json"].textures;
      spawnNewPirateShip();
      spawnNewPirateShip();
      /*for(let i = 0; i < randInt(3,7); i++) {
        let testIsland = new Sprite(resources["sprites/island.png"].texture);
        testIsland.myX = randInt(-2500,2500);
        testIsland.myY = randInt(-2500,2500);
        testIsland.scale.set(50, 50);
        islands.push(testIsland)
        gameScene.addChild(testIsland);
      }*/
      ship = new Sprite(resources["sprites/topDownShip.png"].texture);
      ship.scale.x = 10;
      ship.scale.y = 10;
      gameScene.addChild(ship);
      app.renderer.render(app.stage);
      ship.vx = 0;
      ship.vy = 0;
      ship.x = 750;
      ship.y = 350;
      ship.direction = 90;
      ship.speed = 0;
      ship.turn = 0;
      ship.health = 10;
      ship.anchor.x = 0.5;
      ship.anchor.y = 0.5;
      explorer = new Sprite(id["explorer.png"]);
      gameScene.addChild(explorer);
      explorer.x = ship.x;
      explorer.y = ship.y;
      var left = keyboard("ArrowLeft"), right = keyboard("ArrowRight"), up = keyboard("ArrowUp"), down = keyboard("ArrowDown");
      var space = keyboard(" "), a = keyboard("a"), d = keyboard("d");
      var enter = keyboard("Enter");
      var s = keyboard("s");
      var w = keyboard("w");
      var b = keyboard("b");
      wPress = false, sPress = false;
      b.press = () => {
        if(state === sail) {
          
        }
      }
      w.press = () => {
        wPress = true;
      }
      w.release = () => {
        wPress = false;
      }
      s.press = () => {
        sPress = true;
      }
      s.release = () => {
        sPress = false;
      }
      enter.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          app.renderer.backgroundColor = 0x7777FF;
        }
      }
      space.press = () => {
        fireCannon = 2;
      }
      a.press = () => {
        fireCannon = 1;
      }
      d.press = () => {
        fireCannon = -1;
      }
      left.press = () => {
        ship.turn = 1;
      }
      left.release = () => {
        ship.turn = 0;
      };
      right.press = () => {
        ship.turn = -1;
      }
      right.release = () => {
        ship.turn = 0;
      }
      up.press = () => {
        ++ship.speed
      }
      down.press = () => {
        if(ship.speed > 0) {
          --ship.speed
        }
      }
      if(debug) {
        graphics = new PIXI.Graphics();
        graphics.beginFill(0xFF0000);
        graphics.alpha = 0.5;
        graphics.drawRect((ship.x - ship.width / 2), (ship.y - ship.height / 2), ship.width, ship.height);
        graphics.drawPolygon([100,100,100,200,200,200,200,100]);
        gameScene.addChild(graphics);
      }
      app.ticker.add(delta => gameLoop(delta));
      windSpeed = 1;
      windDirection = 90;
      setTimeout(changeWind,20000 + randInt(-10000,10000))
    }
    function changeWind() {
      windSpeed = randInt(0,5);
      windDirection = randInt(0,360);
      setTimeout(changeWind,20000 + randInt(-10000,10000));
    }
    var shots = [];
   // var islands = [];
    function spawnNewPirateShip(){
      var pirateShip = new Sprite(resources["sprites/pirateshipblack.png"].texture);
      pirateShip.scale.x = 10;
      pirateShip.scale.y = 10;
      pirateShip.direction = 90;
      pirateShip.speed = 1;
      pirateShip.lastFire = Date.now() - 25000;
      pirateShip.shouldFire = true;
      pirateShip.anchor.set(0.5, 0.5);
      pirateShip.myX = randInt(100,700);
      pirateShip.myY = randInt(100,700);
      pirateShip.hit = false;
      pirateShip.health = 10;
      pirateShip.rotation = pointInDirection(pirateShip.direction + 90);
      pirateShip.pilot = new Sprite(resources["sprites/pirateBlob.png"].texture);
      pirateShip.pilot.x = pirateShip.x;
      pirateShip.pilot.y = pirateShip.y;
      pirateShip.pilot.rotation = pirateShip.rotation;
      pirateShips.push(pirateShip);
      gameScene.addChild(pirateShip);
      gameScene.addChild(pirateShip.pilot);
    }
    function drawCollision(){
      graphics.clear();
      graphics.beginFill(0xFF0000);
      graphics.alpha = 0.5;
      var point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      var point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      //var path = [(ship.x - ship.width / 2), (ship.y - ship.height / 2),(ship.x - ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y - ship.height / 2)]
      var path = [point1.x,point1.y, point2.x,point2.y,point3.x,point3.y,point4.x,point4.y];
      graphics.drawPolygon(path);
    }
    var state = introSetup;
    gameScene.visible = true;
    function introSetup(){
      gameScene.visible = false;
      introScene = new Container();
      var introText = 'Press Enter to skip. Press S to speed up. Press W to slow down.\n\n\nHello, brave explorer. We meet again.\n\n\nI assume you are back from Blob Adventures I?\n\n\nWell. You completed that mission well. Almost.\n\n\nI assume you remembered what happened after that?\n\n\nWhat? Is your memory so short? Alright, I will tell you.\n\n\nYou proudly brought in the chests before the king, and then left.\n\n\nWhat happened after that was the king opened them up.\n\n\nAnd then he found that they were stuffed with stinky socks.\n\n\nAt first he suspected you of treason, but then...\n\n\nhe remembered that the blobs use the treasure chests for hampers.\n\n\nThen he sent your superior to get them. He proudly grabbed all the hampers...\n\n\nand then it turned out that the blobs had "hidden" the socks in the hampers.\n\n\nIt seems that the blobs prize the stinky socks as antiques, even more than the treasures.\n\n\nThen the king would have sent you to go retrieve both the chests and the hampers...\n\n\nBut the blobs had moved their treasure overseas.\n\n\nSo, he sends you to swim across the ocean to go retrieve the treasure.\n\n\nFortunately, the queen doubted your swimming abilities and sent you a ship and crew.\n\n\nShe also provided food for the journey.\n\n\nWell, Godspeed! Oh, right. Sailing the boat. Don'+"'"+"t you just want to wing it?\n\n\nNo? Okay. Up speeds up, down slows down. You can't reverse.\n\n\nLeft and right turn, and space fires a double broadside.\n\n\nOh, and A and D fire the black and gray cannons. Have fun!"
      var style = new PIXI.TextStyle({stroke:"#0000ff", fill:"blue"});
      var introMessage = new PIXI.Text(introText,style);
      app.renderer.backgroundColor = 0x000000;
      introScene.addChild(introMessage);
      app.stage.addChild(introScene);
      introScene.y = 250;
      state = intro;
    }
    function intro(){
      var scroll = 0.5;
      if(sPress) {
        scroll *= 4;
      }
      if(wPress) {
        scroll = 0;
      }
      introScene.y -= scroll;
    }
    function loadArray(array, folder, type){
      /// Loop through the array
      for(let i = 0; i < array.length; i++) {
          /// Make a string that we will change and eventually load with the loader
          let newString = "";
          /// If you give it a folder to load stuff from, so that you don't have to type it all yourself
          if(folder) {
          /// Start with that
          newString += folder;
          if(newString[newString.length - 1] != "/") {
              /// Make sure there's a slash at the end
              newString += "/"
          }
          }
          /// Then add that element
          newString += array[i];
          /// If you want to give it a type and not type that as well
          if(type){
            /// Make sure there's a dot at the end
            if(type[0] != ".") {
                newString += ".";
            }
            /// Add the type
            newString += type;
          }
          /// Load it!
          // Console.log what has been loaded console.log(newString,"has been loaded")
          PIXI.loader.add(newString);
      }
    }
    function gameLoop(delta) {
      state(delta);
    }
    function sail(){
      if(ship.health < 4) {
        ship.texture = resources["sprites/topDownShiphurt3.png"].texture;
      } else if (ship.health < 7) {
        ship.texture = resources["sprites/topDownShiphurt2.png"].texture;
      } else if (ship.health < 10) {
        ship.texture = resources["sprites/topDownShiphurt.png"].texture;
      }
      explorer.rotation = pointInDirection(ship.direction - 180);
      var data = direction(ship.speed,ship.direction);
      ship.vx = data.r;
      ship.vy = data.u;
      globalX -= ship.vx;
      globalY -= ship.vy;
   /*   islands.forEach(function(testIsland){
        testIsland.x = globalX + testIsland.myX;
        testIsland.y = globalY + testIsland.myY;
      })*/
      ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      if(debug){
        drawCollision();
      }
      handlePirates();
      handleShots();
      ship.rotation = ((ship.direction + 90) * Math.PI * -1) / 180;
      ship.direction += ship.turn;
      if(fireCannon === 2) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      } else if(fireCannon === 1) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      } else if (fireCannon === -1) {
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      }
    }
    function addNewCannonball(offset, id, launcher) {
      offset = offset || 0;
      let cannonball = new Sprite(resources["sprites/cannonball.png"].texture);
      cannonball.scale.set(5,5);
      cannonball.speed = cannonballSpeed;
      cannonball.direction = launcher.direction + offset;
      /// The goal of the myX and myY settings are to try to make it appear at the launching ship's position
      /// How do we do that?
      /// The cannonball's X will be set to globalX + myX
      /// So globalX + myX will have to equal the launcher's x
      /// In other words, globalX + myX = launcher.x
      /// Therefore, myX will have to equal launcher.x - globalX
      /// Same for Y
      cannonball.myX = launcher.x - globalX;
      cannonball.myY = launcher.y - globalY;
      cannonball.x = globalX + cannonball.myX;
      cannonball.y = globalY + cannonball.myY;
      cannonball.offset = direction(launcher.speed,launcher.direction);
      cannonball.id = id;
      cannonball.delete = false;
      cannonball.launchTime = Date.now();
      shots.push(cannonball);
      gameScene.addChild(cannonball);
    }
    function handleShots(){
      shots.forEach(function(shot, i){
        if(shot.delete) {
          shot.visible = false;
          gameScene.removeChild(shot);
          shots.splice(i, 1);
          return;
        }
        var newData = direction(shot.speed, shot.direction);
        shot.myX += newData.r + shot.offset.r;
        shot.myY += newData.u + shot.offset.u;
        shot.x = globalX + shot.myX;
        shot.y = globalY + shot.myY;
        if(shot.x < -50 || shot.x > 1450 || shot.y < -50 || shot.y > 1000 && Date.now() - 5000 > shot.launchTime) {
          shot.delete = true;
        }
        pirateShips.forEach(function(pShip){
          if(circleInRectangle([[pShip.point1.x, pShip.point1.y], [pShip.point2.x, pShip.point2.y], [pShip.point3.x, pShip.point3.y],[pShip.point4.x, pShip.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 1) {
            shot.delete = true;
            pShip.hit = true;
          }
        });
        if(circleInRectangle([[ship.point1.x, ship.point1.y], [ship.point2.x, ship.point2.y], [ship.point3.x, ship.point3.y],[ship.point4.x, ship.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 0) {
          shot.delete = true;
          --ship.health;
          HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
          if(ship.health < 1) {
            ship.visible = false;
          }
        }
      });
    }
    function handlePirates(){
      pirateShips.forEach(function(pShip, i){
        if(pShip.health < 4) {
          pShip.texture = resources["sprites/pirateshipblackhurt3.png"].texture;
        } else if (pShip.health < 7) {
          pShip.texture = resources["sprites/pirateshipblackhurt2.png"].texture;
        } else if (pShip.health < 10) {
          pShip.texture = resources["sprites/pirateshipblackhurt.png"].texture;
        }
        if(pShip.hit){
          pShip.hit = false;
          --pShip.health;
          if(pShip.health < 1) {
            pShip.visible = false;
            gameScene.removeChild(pShip);
            gameScene.removeChild(pShip.pilot);
            pirateShips.splice(i,1);
            cannonballs += 20;
            ship.health += 5;
            return;
          }
        }
        var badData = direction(pShip.speed, pShip.direction);
        pShip.point1 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point2 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point3 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point4 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        if(debug){
       //   drawPirateCollision();
        }
        pShip.vx = badData.r;
        pShip.vy = badData.u;
        pShip.myX += pShip.vx;
        pShip.myY += pShip.vy;
        pShip.x = globalX + pShip.myX;
        pShip.y = globalY + pShip.myY;
        pShip.z = 0;
        pShip.pilot.x = pShip.x;
        pShip.pilot.y = pShip.y;
        pShip.pilot.z = 1;
        var fireRotation1 = pointTowards(pShip.x, pShip.y, ship.x, ship.y);
        var fireRotation2 = pointTowards(pShip.x, pShip.y, ship.x, ship.y) + 180;
        if((Math.abs(fireRotation1-(pShip.direction + 90)) < 20 || Math.abs(fireRotation2-(pShip.direction+90)) < 20)&& pShip.lastFire + 2500 < Date.now()) {
          pShip.lastFire = Date.now();
          addNewCannonball(90, 0, pShip);
          addNewCannonball(-90, 0, pShip);
        } else if (getDistance(pShip.x, pShip.y, ship.x, ship.y) > 850 && true) {
          var pointTowardsShip = pointTowards(pShip.x, pShip.y, ship.x, ship.y) - 180;
          if(pointTowardsShip < 0) {
            pointTowardsShip += 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.25
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.25
          }
        } else {
            if(Math.abs(fireRotation1-(pShip.direction + 90)) < Math.abs(fireRotation2-(pShip.direction+90))) {
              if((Math.abs(fireRotation1-(pShip.direction + 91)) < Math.abs(fireRotation1-(pShip.direction + 89)))) {
                pShip.direction += 0.25;
              } else {
                pShip.direction -= 0.25;
              }
            } else {
              if((Math.abs(fireRotation2-(pShip.direction + 91)) < Math.abs(fireRotation2-(pShip.direction + 89)))) {
                pShip.direction += 0.25;
              } else {
                pShip.direction -= 0.25;
              }
            } 
        }
        pShip.rotation = pointInDirection(pShip.direction+90); 
      });
    }
    function keyboard(value) {
      let key = {};
      key.value = value;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = event => {
        if (event.key === key.value) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = event => {
        if (event.key === key.value) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      const downListener = key.downHandler.bind(key);
      const upListener = key.upHandler.bind(key);
      
      window.addEventListener(
        "keydown", downListener, false
      );
      window.addEventListener(
        "keyup", upListener, false
      );
      
      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener);
        window.removeEventListener("keyup", upListener);
      };
      
      return key;
    }
  </script>
</body>
</html>