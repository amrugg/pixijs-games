<html>
  <head>
    <link href="favicon.png" type="image/png" rel="icon">
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ship Shooter</title>
</head>
    <style>* {padding: 0; margin: 0}</style>
    <script src="pixi/pixi.min.js"></script>
    <script src="usefulFunctions.js"></script>
    <script src ="bump.js"></script>
<body>
  <script type="text/javascript">
    "use strict";
    var BUMP = new Bump(PIXI);
    var params = getParams();
    function getParams() {
      var params = {};
      location.search.substr(1).split("&").forEach(function(el) {
        var data = el.replace(/\+/g, " ").split("=");
        params[decodeURIComponent(data[0])] = data[1] ? decodeURIComponent(data[1]) : true;
      });
      return params;
    }
    var debug = params.debug || false;
    PIXI.utils.skipHello();
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
    let Application = PIXI.Application,
        Container = PIXI.Container,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        TextureCache = PIXI.utils.TextureCache,
        Sprite = PIXI.Sprite,
        Rectangle = PIXI.Rectangle,
        Graphics = PIXI.Graphics;
    let app = new Application({ 
        width: 800,
        height: 800,              
        antialias: true,
        transparent: false,
        resolution: 1
      }
    );
    /// Fill the screen
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    app.renderer.autoResize = true;
    app.renderer.resize(window.innerWidth, window.innerHeight);
    document.body.appendChild(app.view);
    var gameScene = new Container();
    app.stage.addChild(gameScene);
    var mountX,mountY,knots, knots2, winningText, ship, windSpeed, windDirection, markArrow, creditsScene, arrow, explorer, graphics, data, windOffset, windData, layerOfClouds, windArrow, HUD, id, introScene, wPress, sPress;
    var fireCannon = false;
    var files = ["whitearrow","brownarrow","timber","knot5","knot4","knot3","knot2","cannonballbarrel","knot1","pirateshipblackhurt","pirateshipblackhurt2","pirateshipblackhurt3","cannonball","island","pirateBlob","pirateshipblack","pirateshipred","topDownShip","topDownShipdeath","topDownShiphurt","topDownShiphurt2","topDownShiphurt3"]
    loadArray(files, "sprites", "png");
    loader.add("sprites/treasureHunter.json").load(setup);
    var pirateShips = [];
    var cannonballSpeed = 10;
    var cannonballs = 60;
    var globalX = -200;
    var globalY = 0;
    var divideScale = params.divideScale || 1;
    var islandPositions = [[-50,10], [-50,85], [100,200], [500,-200], [-500,300], [-410, 210],[-320,120],[-320,30],[-370,-40],[-450, -120]]
    var islands = [];
    var telescopeHole = new PIXI.Graphics();
    var keys = {};
    var frigates = [];
    var treasures = [];
    var treasuresLeft = 5;
    var state = introSetup;
    gameScene.visible = true;
    var shots = [];
    var barrels = [];
    var timbers = [];
    var difficultyScale = params.difficultyScale || 1;
    var loot1 = 0;
    var loot2 = 0;
    function setup() {
      telescopeHole.lineStyle(1000*(window.innerWidth/1000),0x000000,1);
      telescopeHole.drawCircle(window.innerWidth/2,window.innerHeight/2,800*(window.innerWidth/1200));
      telescopeHole.endFill();
      telescopeHole.visible = false;
      app.stage.addChild(telescopeHole);
      creditsScene = new PIXI.Container();
      app.stage.addChild(creditsScene);
      creditsScene.visible = false;
      graphics = new PIXI.Graphics();
      id = resources["sprites/treasureHunter.json"].textures;
      /*for(let i = 0; i < randInt(3,7); i++) {
        let testIsland = new Sprite(resources["sprites/island.png"].texture);
        testIsland.myX = randInt(-2500,2500);
        testIsland.myY = randInt(-2500,2500);
        testIsland.scale.set(50, 50);
        islands.push(testIsland)
        gameScene.addChild(testIsland);
      }*/
      ship = new Sprite(resources["sprites/topDownShip.png"].texture);
      ship.scale.x = 10/divideScale;
      ship.scale.y = 10/divideScale;
      gameScene.addChild(ship);
      app.renderer.render(app.stage);
      ship.vx = 0;
      ship.vy = 0;
      ship.x = 750;
      ship.y = 350;
      ship.direction = 89.9999999;
      ship.speed = 0;
      ship.turn = 0;
      ship.health = params.health || 10 * (1/difficultyScale);
      ship.anchor.x = 0.5;
      ship.anchor.y = 0.5;
      explorer = new Sprite(id["explorer.png"]);
      gameScene.addChild(explorer);
      explorer.x = ship.x;
      explorer.y = ship.y;
      let spawn = spawnNewPirateShip;
      spawnRedPirateShip(2000,-1000);
      spawnRedPirateShip(-2000,0);
      spawnRedPirateShip(-3000,0);
      spawnRedPirateShip(0,-3000);
      spawnRedPirateShip(-3000,-3000);
      spawn(1400,350);
      spawn(750,-700);
      spawn(750,1100);
      spawn(-300,350);
      spawn(-400,350)
      spawn(1800,-1000);
      spawn(2200,-1000);
      spawn(-2200,0);
      spawn(-1800,0);
      spawn(-3200,-200);
      spawn(-2800,200);
      spawn(200,-3000);
      spawn(-200,-3000);
      spawn(-3000,-3200);
      spawn(-3000,-2800);
      for(let i = 0; i < islandPositions.length; i++) {
        let newIsland = new Sprite(resources["sprites/island.png"].texture);
        newIsland.scale.set(50/divideScale);
        newIsland.myX = (islandPositions[i][0] * (10/divideScale)) + 650;
        newIsland.myY = (islandPositions[i][1] * -1 * (10/divideScale)) + 350;
        // console.log(islandPositions[i][0],islandPositions[i][1])
        islands.push(newIsland);
        gameScene.addChild(newIsland);
      }
      HUD = new PIXI.Text("Cannonballs: " + cannonballs.toString() + " Health: " + (10).toString());
      HUD.x = innerWidth - 400;
      gameScene.addChild(HUD);
      gameScene.addChild(graphics);
      var left = keyboard("ArrowLeft"), right = keyboard("ArrowRight"), up = keyboard("ArrowUp"), down = keyboard("ArrowDown");
      var space = keyboard(" "), a = keyboard("a"), d = keyboard("d");
      var e = keyboard("e");
      var m = keyboard("m");
      var h = keyboard("h");
      var s = keyboard("s");
      var w = keyboard("w");
      var b = keyboard("b");
      var t = keyboard("t");
      var v = keyboard("v");
      t.press = () => {
        if(state === sail) {
          state = mountTelescope;
        } else if(state === telescope){
          telescopeHole.visible = false;
          globalX = mountX;
          globalY = mountY;
          ship.x = 750;
          ship.y = 350;
          state = sail;
        }
      }
      wPress = false, sPress = false;
      b.press = () => {
        if(state === sail) {
          
        }
      }
      w.press = () => {
        wPress = true;
      }
      w.release = () => {
        wPress = false;
      }
      s.press = () => {
        sPress = true;
      }
      s.release = () => {
        sPress = false;
      }
      e.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          setTimeout(changeWind,30000 + randInt(-10000,10000));
          app.renderer.backgroundColor = 0x7777FF;
          difficultyScale = 0.5;
          cannonballs = Math.round(cannonballs * (1/difficultyScale));
          ship.health = Math.round(10 * (1/difficultyScale));
          updateHUD();
        }
      }
      v.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          setTimeout(changeWind,30000 + randInt(-10000,10000));
          app.renderer.backgroundColor = 0x7777FF;
          difficultyScale = 0.25;
          cannonballs = Infinity;
          ship.health = ship.health = Math.round(10 * (1/difficultyScale));
          updateHUD();
        }
      }
      m.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          setTimeout(changeWind,30000 + randInt(-10000,10000));
          app.renderer.backgroundColor = 0x7777FF;
          difficultyScale = 0.75;
          cannonballs = Math.round(cannonballs * (1/difficultyScale));
          ship.health = Math.round(10 * (1/difficultyScale));
          updateHUD();
        }
      }
      h.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          setTimeout(changeWind,30000 + randInt(-10000,10000));
          app.renderer.backgroundColor = 0x7777FF;
          difficultyScale = 1;
          cannonballs = Math.round(cannonballs * (1/difficultyScale));
          ship.health = Math.round(10 * (1/difficultyScale));
          updateHUD();
        }
      }
      space.press = () => {
        fireCannon = 2;
      }
      a.press = () => {
        fireCannon = 1;
      }
      d.press = () => {
        fireCannon = -1;
      }
      left.press = () => {
        ship.turn = 1;
        keys.leftPress = true;
      }
      left.release = () => {
        ship.turn = 0;
        keys.leftPress = false;
      };
      right.press = () => {
        ship.turn = -1;
        keys.rightPress = true;
      }
      right.release = () => {
        ship.turn = 0;
        keys.rightPress = false;
      }
      up.press = () => {
        if(state === sail && ship.speed < 5) {
          ++ship.speed;
        }
        keys.upPress = true;
      }
      up.release = () => {
        keys.upPress = false;
      }
      down.press = () => {
        if(ship.speed > 0 && state === sail) {
          --ship.speed
        }
        keys.downPress = true;
      }
      down.release = () => {
        keys.downPress = false;
      }

      app.ticker.add(delta => gameLoop(delta));
      windSpeed = 1;
      windDirection = 90;
      arrow = new Sprite(resources["sprites/brownarrow.png"].texture);
      arrow.scale.set(0.025);
      arrow.x = 100;
      arrow.y = window.innerHeight - 100;
      arrow.anchor.set(0.5,0.5);
      gameScene.addChild(arrow);
      windArrow = new Sprite(resources["sprites/whitearrow.png"].texture);
      windArrow.scale.set(0.025);
      windArrow.x = 200;
      windArrow.y = window.innerHeight - 100;
      windArrow.anchor.set(0.5,0.5);
      gameScene.addChild(windArrow);
      markArrow = new Sprite(resources["sprites/pirateshipred.png"].texture);
      markArrow.y = innerHeight - 100;
      markArrow.x = 300;
      markArrow.scale.set(3);
      markArrow.anchor.set(0.5);
      gameScene.addChild(markArrow);
      knots = new Sprite(resources["sprites/knot1.png"].texture);
      knots.y = innerHeight - 100;
      knots.x = 400;
      knots.anchor.set(0.5);
      knots.scale.set(5);
      gameScene.addChild(knots);
      knots2 = new Sprite(resources["sprites/knot1.png"].texture);
      knots2.y = innerHeight - 100;
      knots2.x = 500;
      knots2.anchor.set(0.5);
      knots2.scale.set(5);
      gameScene.addChild(knots2);
      layerOfClouds = new PIXI.Graphics();
      layerOfClouds.beginFill(0x000000);
      layerOfClouds.drawRect(0,0,innerWidth,innerHeight);
      layerOfClouds.alpha = windSpeed / 10;
      gameScene.addChild(layerOfClouds);
    }
    function changeWind() {
      windSpeed = randInt(0,Math.round(5 * difficultyScale));
      windDirection = randInt(0,360);
      layerOfClouds.alpha = windSpeed / 10;
      setTimeout(changeWind,30000 + randInt(-10000 * 0 ,10000*0));
    }
    function spawnNewPirateShip(x,y) {
      let pirateShip = new Sprite(resources["sprites/pirateshipblack.png"].texture);
      pirateShip.scale.x = 10/divideScale;
      pirateShip.scale.y = 10/divideScale;
      pirateShip.direction = 90;
      pirateShip.speed = 1 * difficultyScale;
      pirateShip.lastFire = Date.now() - 25000;
      pirateShip.anchor.set(0.5, 0.5);
      pirateShip.myX = x;
      pirateShip.myY = y;
      pirateShip.start = true;
      pirateShip.hit = false;
      pirateShip.health = 10;
      pirateShip.rotation = pointInDirection(pirateShip.direction + 90);
      pirateShip.pilot = new Sprite(resources["sprites/pirateBlob.png"].texture);
      pirateShip.pilot.x = pirateShip.x;
      pirateShip.pilot.y = pirateShip.y;
      pirateShip.pilot.rotation = pirateShip.rotation;
      pirateShip.lootNum;
      /// Let's see. We want the probability of getting a barrel or timber when they are equal to be 50/50.
      /// Do we want when it's 1 more barrel than timber 25/75 in favor of timber?
      /// Sounds kind of extreme...
      /// What about tipping it 40/60 in favor of timber?
      /// That sounds good. How would we do that?
      /// Well, we would get a randInt between 1 and 100.
      /// And that would be a percent.
      /// Right. So let's say we have a variable called barrelDiff. If the barrels are 1 more than timber...
      /// It's 1, if it's 1 less, then it's -1.
      /// So supposing barrelDiff was 1.
      /// Ordinarily it would be barrel if it was more than 50 and timber if less.
      /// Correct. So that would be "if(randomNumber > 50) {pirateShip.lootNum = 1}".
      /// Right. But how about this? "if(randomNumber > 50 + (barrelDiff * 10)) {pirateShip.lootNum = 1}".
      /// Sounds good! Let's go!
      let randomNumber = randInt(1,100);
      let barrelDiff = loot1 - loot2;
      let threshold = 50 + (barrelDiff * 20);
      if(randomNumber > threshold) {
        pirateShip.lootNum = 1;
      } else {
        pirateShip.lootNum = 0;
      }
      console.log(randomNumber, threshold,loot1,loot2);
      if(pirateShip.lootNum > 0) {
        pirateShip.loot = new Sprite(resources["sprites/cannonballbarrel.png"].texture);
        pirateShip.loot.scale.set(3);
        ++loot1;
      } else {
        pirateShip.loot = new Sprite(resources["sprites/timber.png"].texture);
        pirateShip.loot.scale.set(3);
        ++loot2;
      }
      pirateShip.loot.anchor.set(0.5);
      pirateShips.push(pirateShip);
      gameScene.addChild(pirateShip);
      gameScene.addChild(pirateShip.pilot);
      gameScene.addChild(pirateShip.loot);

    }
    function drawCollision() {
      graphics.clear();
      graphics.beginFill(0xFF0000);
      graphics.alpha = 0.5;
      var point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      var point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      //var path = [(ship.x - ship.width / 2), (ship.y - ship.height / 2),(ship.x - ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y - ship.height / 2)]
      //var path = [point1.x,point1.y, point2.x,point2.y,point3.x,point3.y,point4.x,point4.y];
      var path = [ship.l1.p1.x,ship.l1.p1.y,ship.l2.p1.x,ship.l2.p1.y,ship.l3.p1.x,ship.l3.p1.y,ship.l4.p1.x,ship.l4.p1.y,ship.l1.p1.x,ship.l1.p1.y]
      //console.log(path)
      graphics.drawPolygon(path);
      parseIslandCollision();
      islands.forEach(function(island){
        path = [island.p1.x,island.p1.y,island.p2.x,island.p2.y,island.p3.x,island.p3.y,island.p4.x,island.p4.y,island.p5.x,island.p5.y,island.p6.x,island.p6.y,island.p7.x,island.p7.y,island.p8.x,island.p8.y,island.p9.x,island.p9.y,island.p10.x,island.p10.y,island.p11.x,island.p11.y,island.p12.x,island.p12.y,island.p13.x,island.p13.y,island.p14.x,island.p14.y,island.p1.x,island.p1.y];
        //path = [island.l1.p1.x,island.l1.p1.y,island.l2.p1.x,island.l2.p1.y, island.l3.p1.x,island.l3.p1.y, island.l4.p1.x, island.l4.p1.y,island.l5.p1.x,island.l5.p1.y,island.l6.p1.x,island.l6.p1.y,island.l7.p1.x,island.l7.p1.y,island.l8.p1.x,island.l8.p1.y,island.l9.p1.x,island.l9.p1.y,island.l10.p1.x,island.l10.p1.y,island.l11.p1.x,island.l11.p1.y,island.l12.p1.x,island.l12.p1.y,island.l13.p1.x,island.l13.p1.y,island.l14.p1.x,island.l14.p1.y,island.l1.p1.x,island.l1.p1.y];
        graphics.drawPolygon(path);
      })
    }
    function credits() {
      gameScene.visible = false;
      app.renderer.backgroundColor = 0x000000
      creditsScene.visible = true;
      var creditsText = "Thank you for playing Blob Adventures II!\n\n\n\nProgramming done by Aaron Rugg.\n\n\n\nFavicon done by Alexander Rugg.\n\n\n\nBlobs, treasure and explorer were found for free by Lanea Zimmerman.\n\n\n\nFavicon and all other graphics were done by Alexander Rugg."
      var style = new PIXI.TextStyle({stroke:"#0000ff", fill:"blue"});
      var creditsMessage = new PIXI.Text(creditsText,style);
      creditsScene.addChild(creditsMessage);
      creditsScene.y = 500;
      state = creditsScroll;
    }
    function creditsScroll() {
      creditsScene.y -= 0.5
    }
    function parseIslandCollision() {
      islands.forEach(function(island) {
        island.p1 = {x:island.x + 75, y: island.y + 25};
        island.p2 = {x:island.x + 410,y: island.y + 25};
        island.p3 = {x:island.x + 550,y:island.y + 125};
        island.p4 = {x:island.x + 625,y:island.y + 200};
        island.p5 = {x:island.x + 625,y:island.y + 300};
        island.p6 = {x:island.x + 775,y:island.y + 475};
        island.p7 = {x:island.x + 925,y:island.y + 475};
        island.p8 = {x:island.x + 925,y:island.y + 675};
        island.p9 = {x:island.x + 725,y:island.y + 675};
        island.p10 = {x:island.x + 725,y:island.y + 625};
        island.p11 = {x:island.x + 500,y:island.y + 625};
        island.p12 = {x:island.x + 300,y:island.y + 525};
        island.p13 = {x: island.x + 150,y:island.y + 525};
        island.p14 = {x: island.x + 50,y:island.y + 100};
        island.l1 = {p1:island.p1,p2:island.p2};
        island.l2 = {p1:island.p2,p2:island.p3};
        island.l3 = {p1:island.p3,p2:island.p4};
        island.l4 = {p1:island.p4,p2:island.p5};
        island.l5 = {p1:island.p5,p2:island.p6};
        island.l6 = {p1:island.p6,p2:island.p7};
        island.l7 = {p1:island.p7,p2:island.p8};
        island.l8 = {p1:island.p8,p2:island.p9};
        island.l9 = {p1:island.p7,p2:island.p10};
        island.l10 = {p1:island.p10,p2:island.p11};
        island.l11 = {p1:island.p11,p2:island.p12};
        island.l12 = {p1:island.p12,p2:island.p13};
        island.l13 = {p1:island.p13,p2:island.p14};
        island.l14 = {p1:island.p14,p2:island.p1};
      })
    }
    function spawnRedPirateShip(x,y) {
      if(x === undefined) {
        x = randInt(-5000,2000);
      }
      if(y === undefined) {
        y = randInt(-5000,2000);
      }
      var frigate = new Sprite(resources["sprites/pirateshipred.png"].texture);
      frigate.scale.set(20/divideScale);
      frigate.direction = 90;
      frigate.speed = 2 * difficultyScale;
      frigate.lastFire = Date.now() - 50000;
      frigate.myX = x;
      frigate.myY = y;
      console.log(frigate.myY)
      frigate.anchor.set(0.5);
      frigate.hit = false;
      frigate.health = 20;
      frigate.rotation = pointInDirection(frigate.direction + 90);
      frigate.pilot = new Sprite(resources["sprites/pirateBlob.png"].texture);
      frigate.pilot.x = frigate.x;
      frigate.pilot.y = frigate.y;
      frigate.pilot.rotation = frigate.rotation;
      frigate.pilot2 = new Sprite(resources["sprites/pirateBlob.png"].texture);
      frigate.pilot2.x = frigate.x;
      frigate.pilot2.y = frigate.y;
      frigate.pilot2.rotation = frigate.rotation;
      frigate.pilot3 = new Sprite(resources["sprites/pirateBlob.png"].texture);
      frigate.pilot3.x = frigate.x;
      frigate.pilot3.y = frigate.y;
      frigate.pilot3.rotation = frigate.rotation;
      frigate.treasure = new Sprite(id["treasure.png"]);
      frigate.treasure.rotation = frigate.rotation;
      frigate.start = true;
      frigates.push(frigate);
      gameScene.addChild(frigate);
      gameScene.addChild(frigate.pilot)
      gameScene.addChild(frigate.pilot2)
      gameScene.addChild(frigate.pilot3);
      gameScene.addChild(frigate.treasure);
    }
    function introSetup() {
      gameScene.visible = false;
      introScene = new Container();
      var introText = 'Press V, E, M, or H to do Very Easy, Easy, Medium, or Hard.\nPress S to speed up intro. Press W to slow down intro.\n\n\nHello, brave explorer. We meet again.\n\n\nI assume you are back from Blob Adventures I?\n\n\nWell. You completed that mission well. Almost.\n\n\nI assume you remembered what happened after that?\n\n\nWhat? Is your memory so short? Alright, I will tell you.\n\n\nYou proudly brought in the chests before the king, and then left.\n\n\nWhat happened after that was the king opened them up.\n\n\nAnd then he found that they were stuffed with stinky socks.\n\n\nAt first he suspected you of treason, but then...\n\n\nhe remembered that the blobs use the treasure chests for hampers.\n\n\nThen he sent your superior to get them. He proudly grabbed all the hampers...\n\n\nand then it turned out that the blobs had "hidden" the socks in the hampers.\n\n\nIt seems that the blobs prize the stinky socks as antiques, even more than the treasures.\n\n\nThen the king would have sent you to go retrieve both the chests and the hampers...\n\n\nBut the blobs had moved their treasure overseas.\n\n\nSo, he sends you to swim across the ocean to go retrieve the treasure.\n\n\nFortunately, the queen doubted your swimming abilities and sent you a ship and crew.\n\n\nBeware of the islands while you'+"'"+'re sailing! You may wreck just hitting their sand banks.\n\n\nThe treasure seems to be hoarded by the haughty red sail ships.\n\n\nBy the way, the king said to only look for 5 treasure chests, because the blobs packed it down.\n\n\nWell, Godspeed! Oh, right. Sailing the boat. Don'+"'"+"t you just want to wing it?\n\n\nNo? Okay. Up speeds up, down slows down. You can't reverse.\n\n\nLeft and right turn, and space fires a double broadside.\n\n\nOh, and A and D fire the black and gray cannons.\n\n\nT goes into Telescope mode, where you can look about the islands and see things.\n\n\nBut you still might be creamed while you're not looking. Have fun!"
      var style = new PIXI.TextStyle({stroke:"#0000ff", fill:"blue"});
      var introMessage = new PIXI.Text(introText,style);
      app.renderer.backgroundColor = 0x000000;
      introScene.addChild(introMessage);
      app.stage.addChild(introScene);
      introScene.y = 250;
      state = intro;
    }
    function intro() {
      var scroll = 0.5;
      if(sPress) {
        scroll *= 4;
      }
      if(wPress) {
        scroll = 0;
      }
      introScene.y -= scroll;
    }
    function loadArray(array, folder, type) {
      /// Loop through the array
      for(let i = 0; i < array.length; i++) {
          /// Make a string that we will change and eventually load with the loader
          let newString = "";
          /// If you give it a folder to load stuff from, so that you don't have to type it all yourself
          if(folder) {
          /// Start with that
          newString += folder;
          if(newString[newString.length - 1] != "/") {
              /// Make sure there's a slash at the end
              newString += "/"
          }
          }
          /// Then add that element
          newString += array[i];
          /// If you want to give it a type and not type that as well
          if(type){
            /// Make sure there's a dot at the end
            if(type[0] != ".") {
                newString += ".";
            }
            /// Add the type
            newString += type;
          }
          /// Load it!
          // Console.log what has been loaded console.log(newString,"has been loaded")
          PIXI.loader.add(newString);
      }
    }
    function gameLoop(delta) {
      state(delta);
    }
    function wait() {

    }
    function mountTelescope() {
      telescopeHole.visible = true;
      state = telescope;
      // Ship.myX + globalX needs to equal ship.x
      ship.myX = ship.x - globalX;
      ship.myY = ship.y - globalY;
      mountX = globalX;
      mountY = globalY;
    }
    function telescope() {
      if(debug){
        drawCollision();
      }
      if(ship.health < 4) {
        ship.texture = resources["sprites/topDownShiphurt3.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 7) {
        ship.texture = resources["sprites/topDownShiphurt2.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 10) {
        ship.texture = resources["sprites/topDownShiphurt.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else {
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      }
      ship.l1 = {p1:ship.point1,p2:ship.point2};
      ship.l2 = {p1:ship.point2,p2:ship.point3};
      ship.l3 = {p1:ship.point3,p2:ship.point4};
      ship.l4 = {p1:ship.point4,p2:ship.point1};
      handlePirates();
      handleShots();
      islands.forEach(function(testIsland){
        testIsland.x = globalX + testIsland.myX;
        testIsland.y = globalY + testIsland.myY;
      });
      var data = direction(ship.speed,ship.direction);
      var windData = direction(windSpeed * Math.abs(1-(Math.abs(windDirection - ship.direction)/100)),windDirection);
      ship.vx = data.r + windData.r;
      ship.vy = data.u + windData.u;
      ship.myX += ship.vx;
      ship.myY += ship.vy;
      ship.x = ship.myX + globalX;
      ship.y = ship.myY + globalY;
      if(keys.leftPress) {
        globalX += 25;
      }
      if(keys.rightPress) {
        globalX -= 25;
      }
      if(keys.upPress) {
        globalY += 25;
      }
      if(keys.downPress) {
        globalY -= 25;
      }
      explorer.rotation = pointInDirection(ship.direction - 180);
      explorer.x = ship.x;
      explorer.y = ship.y;
    }
    function sail() {
      handleShip();
      handleIslands();
      handlePirates();
      handleFrigates();
      handleLoot();
      handleShots();
      handleTreasures();
      fireCannonballs();
      handleDashboard();
    }
    function shipIntersectingIslands(){
      var v = false;
      var l = lineCollideLine;
      islands.forEach(function(island){
        if(getDistance(island.x,island.y,ship.x,ship.y > 1000)){
          //return;
        }
        /*if(l(ship.l1,island.l1)||l(ship.l1,island.l2)||l(ship.l1,island.l3)||l(ship.l1,island.l4||l(ship.l1,island.l5)||l(ship.l1,island.l6)||l(ship.l1,island.l7)||l(ship.l1,island.l8)||l(ship.l1,island.l9)||l(ship.l1,island.l10)||l(ship.l1,island.l11)||l(ship.l1,island.l12)||l(ship.l1,island.l13)||l(ship.l1,island.l14))){
          v=true;
        }*/
        if(l(ship.l1,island.l1)||l(ship.l1,island.l2)||l(ship.l1,island.l3)||l(ship.l1,island.l4)||l(ship.l1,island.l5)||l(ship.l1,island.l6)){
          v = true;
        }
        if(l(ship.l1,island.l7)||l(ship.l1,island.l8)||l(ship.l1,island.l9)||l(ship.l1,island.l10)||l(ship.l1,island.l11)||l(ship.l1,island.l12)||l(ship.l1,island.l13)||l(ship.l1,island.l14)) {
          v = true;
        }
        if(l(ship.l2,island.l1)||l(ship.l2,island.l2)||l(ship.l2,island.l3)||l(ship.l2,island.l4)||l(ship.l2,island.l5)||l(ship.l2,island.l6)){
          v = true;
        }
        if(l(ship.l2,island.l7)||l(ship.l2,island.l8)||l(ship.l2,island.l9)||l(ship.l2,island.l10)||l(ship.l2,island.l11)||l(ship.l2,island.l12)||l(ship.l2,island.l13)||l(ship.l2,island.l14)) {
          v = true;
        }
        if(l(ship.l3,island.l1)||l(ship.l3,island.l2)||l(ship.l3,island.l3)||l(ship.l3,island.l4)||l(ship.l3,island.l5)||l(ship.l3,island.l6)){
          v = true;
        }
        if(l(ship.l3,island.l7)||l(ship.l3,island.l8)||l(ship.l3,island.l9)||l(ship.l3,island.l10)||l(ship.l3,island.l11)||l(ship.l3,island.l12)||l(ship.l3,island.l13)||l(ship.l3,island.l14)) {
          v = true;
        }
        if(l(ship.l4,island.l1)||l(ship.l4,island.l2)||l(ship.l4,island.l3)||l(ship.l4,island.l4)||l(ship.l4,island.l5)||l(ship.l4,island.l6)){
          v = true;
        }
        if(l(ship.l4,island.l7)||l(ship.l4,island.l8)||l(ship.l4,island.l9)||l(ship.l4,island.l10)||l(ship.l4,island.l11)||l(ship.l4,island.l12)||l(ship.l4,island.l13)||l(ship.l4,island.l14)) {
          v = true;
        }
        /*if(l(ship.l1,island.l2)){
          v = true;
        }
        if(l(ship.l1,island.l3)){
          v = true;
        }
        if(l(ship.l1,island.l4)){
          v = true;
        } */
      }
      );
      return v;
    }
    function die() {
      setTimeout(function() {
      ship.texture = resources["sprites/topDownShipdeath.png"].texture;
      graphics.beginFill(0x000000);
      graphics.alpha = 0;
      graphics.drawRect(0,0,window.innerWidth,window.innerHeight);
      state = dying;
      },1000);
      state = wait;
    }
    function dying() {
      if(graphics.alpha > 0.999){
        state = credits;
      }
      graphics.alpha += 0.01;
    }
    function addNewCannonball(offset, id, launcher,x,y) {
      offset = offset || 0;
      let cannonball = new Sprite(resources["sprites/cannonball.png"].texture);
      cannonball.scale.set(5/divideScale,5/divideScale);
      cannonball.speed = cannonballSpeed;
      cannonball.direction = launcher.direction + offset;
      /// The goal of the myX and myY settings are to try to make it appear at the launching ship's position
      /// How do we do that?
      /// The cannonball's X will be set to globalX + myX
      /// So globalX + myX will have to equal the launcher's x
      /// In other words, globalX + myX = launcher.x
      /// Therefore, myX will have to equal launcher.x - globalX
      /// Same for Y
      if(x == undefined) { 
        cannonball.myX = launcher.x - globalX;
      } else {
        cannonball.myX = x - globalX;
      }
      if(y === undefined) {
        cannonball.myY = launcher.y - globalY;
      } else {
        cannonball.myY = y - globalY;
      }
      cannonball.x = globalX + cannonball.myX;
      cannonball.y = globalY + cannonball.myY;
      cannonball.offset = direction(launcher.speed,launcher.direction);
      cannonball.id = id;
      cannonball.delete = false;
      cannonball.launchTime = Date.now();
      shots.push(cannonball);
      gameScene.addChild(cannonball);
    }
    function handleShots() {
      shots.forEach(function(shot, i){
        if(shot.delete) {
          shot.visible = false;
          gameScene.removeChild(shot);
          shots.splice(i, 1);
          return;
        }
        var newData = direction(shot.speed, shot.direction);
        shot.myX += newData.r + shot.offset.r;
        shot.myY += newData.u + shot.offset.u;
        shot.x = globalX + shot.myX;
        shot.y = globalY + shot.myY;
        if(shot.x < -50 || shot.x > 1450 || shot.y < -50 || shot.y > 1000 && Date.now() - 5000 > shot.launchTime) {
          shot.delete = true;
        }
        pirateShips.forEach(function(pShip){
          if(circleInRectangle([[pShip.point1.x, pShip.point1.y], [pShip.point2.x, pShip.point2.y], [pShip.point3.x, pShip.point3.y],[pShip.point4.x, pShip.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 1) {
            shot.delete = true;
            pShip.hit = true;
          }
        });
        frigates.forEach(function(pShip){
          if(circleInRectangle([[pShip.point1.x, pShip.point1.y], [pShip.point2.x, pShip.point2.y], [pShip.point3.x, pShip.point3.y],[pShip.point4.x, pShip.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 1) {
            shot.delete = true;
            pShip.hit = true;
          }
        });
        if(circleInRectangle([[ship.point1.x, ship.point1.y], [ship.point2.x, ship.point2.y], [ship.point3.x, ship.point3.y],[ship.point4.x, ship.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 0) {
          shot.delete = true;
          --ship.health;
          updateHUD();
          if(ship.health < 1) {
            state = die;
          }
          if(state === telescope) {
            telescopeHole.visible = false;
            globalX = mountX;
            globalY = mountY;
            ship.x = 750;
            ship.y = 350;
            state = sail;
          }
        }
      });
    }
    function handlePirates() {
      pirateShips.forEach(function(pShip, i){
        if(pShip.health < 4) {
          pShip.texture = resources["sprites/pirateshipblackhurt3.png"].texture;
        } else if (pShip.health < 7) {
          pShip.texture = resources["sprites/pirateshipblackhurt2.png"].texture;
        } else if (pShip.health < 10) {
          pShip.texture = resources["sprites/pirateshipblackhurt.png"].texture;
        }
        if(pShip.hit){
          pShip.hit = false;
          --pShip.health;
          if(pShip.health < 1) {
            pShip.visible = false;
            gameScene.removeChild(pShip);
            gameScene.removeChild(pShip.pilot);
            if(pShip.lootNum > 0) {
              spawnNewCannonballBarrel(pShip.loot.x,pShip.loot.y,pShip.loot.rotation);
            } else {
              spawnNewTimberStack(pShip.loot.x,pShip.loot.y,pShip.loot.rotation);
            }
            gameScene.removeChild(pShip.loot);
            pirateShips.splice(i,1);
            return;
          }
        }
        var badData = direction(pShip.speed, pShip.direction);
        pShip.point1 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point2 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point3 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point4 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        if(debug){
       //   drawPirateCollision();
        }
        pShip.vx = badData.r;
        pShip.vy = badData.u;
        pShip.myX += pShip.vx;
        pShip.myY += pShip.vy;
        pShip.x = globalX + pShip.myX;
        pShip.y = globalY + pShip.myY;
        pShip.z = 0;
        pShip.pilot.x = pShip.x;
        pShip.pilot.y = pShip.y;
        pShip.loot.x = pShip.x;
        pShip.loot.y = pShip.y;
        pShip.loot.rotation = pointInDirection(pShip.direction);
        pShip.pilot.z = 1;
        var fireRotation1 = pointTowards(pShip.x, pShip.y, ship.x, ship.y);
        var fireRotation2 = pointTowards(pShip.x, pShip.y, ship.x, ship.y) + 180;
        /// Order of priorites:
        /// 1. Flee islands.
        /// 2. Execute a good shot.
        /// 3. Set up a good shot if close enough.
        /// 4. Search for the ship.

        if(nearestIsland(pShip).distance < 1400){
          /// Land ho! Turn away!
          var dangerIsland = nearestIsland(pShip);
          var correctDirection = pointTowards(pShip.x,pShip.y,dangerIsland.x,dangerIsland.y);
          //pShip.direction = correctDirection;
          if(correctDirection < 0) {
            correctDirection += 360;
          } else if (correctDirection > 360) {
            correctDirection -= 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.75 * difficultyScale;
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.75 * difficultyScale;
          }
        } else if(((Math.abs(fireRotation1-(pShip.direction + 90)) < 20 * difficultyScale || Math.abs(fireRotation2-(pShip.direction+90)) < 20 * difficultyScale))&& (pShip.lastFire + (1000 / difficultyScale)) < Date.now()) {
          pShip.lastFire = Date.now();
          addNewCannonball(90, 0, pShip);
          addNewCannonball(-90, 0, pShip);
        } else if (getDistance(pShip.x, pShip.y, ship.x, ship.y) > 850 && true) {
          var pointTowardsShip = pointTowards(pShip.x, pShip.y, ship.x, ship.y) - 180;
          if(pointTowardsShip < 0) {
            pointTowardsShip += 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.75 * difficultyScale;
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.75 * difficultyScale;
          }
        } else {
            if(Math.abs(fireRotation1-(pShip.direction + 90)) < Math.abs(fireRotation2-(pShip.direction+90))) {
              if((Math.abs(fireRotation1-(pShip.direction + 91)) < Math.abs(fireRotation1-(pShip.direction + 89)))) {
                pShip.direction += 0.75 * difficultyScale;
              } else {
                pShip.direction -= 0.75 * difficultyScale;
              }
            } else {
              if((Math.abs(fireRotation2-(pShip.direction + 91)) < Math.abs(fireRotation2-(pShip.direction + 89)))) {
                pShip.direction += 0.75 * difficultyScale;
              } else {
                pShip.direction -= 0.75 * difficultyScale;
              }
            } 
        }
        pShip.rotation = pointInDirection(pShip.direction+90); 
      });
    }
    function handleFrigates() {
      frigates.forEach(function(pShip, i){
        if(pShip.health < 4) {
          pShip.texture = resources["sprites/pirateshipblackhurt3.png"].texture;
        } else if (pShip.health < 7) {
          pShip.texture = resources["sprites/pirateshipblackhurt2.png"].texture;
        } else if (pShip.health < 10) {
          pShip.texture = resources["sprites/pirateshipblackhurt.png"].texture;
        }
        if(pShip.hit){
          pShip.hit = false;
          --pShip.health;
          if(pShip.health < 1) {
            pShip.visible = false;
            gameScene.removeChild(pShip);
            gameScene.removeChild(pShip.pilot);
            spawnNewTreasureChest(pShip.treasure.x,pShip.treasure.y);
            gameScene.removeChild(pShip.pilot2);
            gameScene.removeChild(pShip.pilot3);
            gameScene.removeChild(pShip.treasure);
            frigates.splice(i,1);
            return;
          }
        }
        var badData = direction(pShip.speed, pShip.direction);
        pShip.point1 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point2 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point3 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point4 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        if(debug){
       //   drawPirateCollision();
        }
        pShip.vx = badData.r;
        pShip.vy = badData.u;
        pShip.myX += pShip.vx;
        pShip.myY += pShip.vy;
        pShip.x = globalX + pShip.myX;
        pShip.y = globalY + pShip.myY;
        pShip.z = 0;
        pShip.pilot.x = pShip.x;
        pShip.pilot.y = pShip.y;
        var backwardData = direction(-100,pShip.direction);
        pShip.pilot2.x = pShip.x + backwardData.r;
        pShip.pilot2.y = pShip.y + backwardData.u;
        var muchForwardData = direction(160,pShip.direction);
        pShip.pilot3.x = pShip.x + muchForwardData.r;
        pShip.pilot3.y = pShip.y + muchForwardData.u;
        var forwardData = direction(100,pShip.direction);
        pShip.treasure.x = pShip.x + forwardData.r;
        pShip.treasure.y = pShip.y + forwardData.u;
        pShip.treasure.rotation = pShip.rotation;
        pShip.pilot.z = 1;
        var fireRotation1 = pointTowards(pShip.x, pShip.y, ship.x, ship.y);
        var fireRotation2 = pointTowards(pShip.x, pShip.y, ship.x, ship.y) + 180;
        /// Order of priorites:
        /// 1. Flee islands.
        /// 2. Execute a good shot.
        /// 3. Set up a good shot if close enough.
        /// 4. Search for the ship.
        
        /// Always fire if it is a good shot, but we want to be able to turn away too.
        if((Math.abs(fireRotation1-(pShip.direction + 90)) < 90 * difficultyScale || Math.abs(fireRotation2-(pShip.direction+90)) < 90 * difficultyScale)&& (pShip.lastFire + 1000 / difficultyScale) < Date.now()) {
          pShip.lastFire = Date.now();
          addNewCannonball(90, 0, pShip);
          addNewCannonball(90, 0, pShip,direction(100,pShip.direction).r + pShip.x,direction(100,pShip.direction).u + pShip.y);
          addNewCannonball(90, 0, pShip,direction(-100,pShip.direction).r + pShip.x,direction(-100,pShip.direction).u + pShip.y);
          addNewCannonball(90, 0, pShip,direction(-200,pShip.direction).r + pShip.x,direction(-200,pShip.direction).u + pShip.y);
          addNewCannonball(-90, 0, pShip);
          addNewCannonball(-90, 0, pShip,direction(100,pShip.direction).r + pShip.x,direction(100,pShip.direction).u + pShip.y);
          addNewCannonball(-90, 0, pShip,direction(-100,pShip.direction).r + pShip.x,direction(-100,pShip.direction).u + pShip.y);
          addNewCannonball(-90, 0, pShip,direction(-200,pShip.direction).r + pShip.x,direction(-200,pShip.direction).u + pShip.y);
        }
        if(nearestIsland(pShip).distance < 2000){
          /// Land ho! Turn away!
          var dangerIsland = nearestIsland(pShip);
          var correctDirection = pointTowards(pShip.x,pShip.y,dangerIsland.x,dangerIsland.y);
          //pShip.direction = correctDirection;
          if(correctDirection < 0) {
            correctDirection += 360;
          } else if (correctDirection > 360) {
            correctDirection -= 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.25 * pShip.speed * difficultyScale;
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.25 * pShip.speed * difficultyScale;
          }
        } else if (getDistance(pShip.x, pShip.y, ship.x, ship.y) > 850) {
          var pointTowardsShip = pointTowards(pShip.x, pShip.y, ship.x, ship.y) - 180;
          if(pointTowardsShip < 0) {
            pointTowardsShip += 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.25 * pShip.speed * difficultyScale
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.25 * pShip.speed * difficultyScale;
          }
        } else {
            if(Math.abs(fireRotation1-(pShip.direction + 90)) < Math.abs(fireRotation2-(pShip.direction+90))) {
              if((Math.abs(fireRotation1-(pShip.direction + 91)) < Math.abs(fireRotation1-(pShip.direction + 89)))) {
                pShip.direction += 0.25 * pShip.speed * difficultyScale;
              } else {
                pShip.direction -= 0.25 * pShip.speed * difficultyScale;
              }
            } else {
              if((Math.abs(fireRotation2-(pShip.direction + 91)) < Math.abs(fireRotation2-(pShip.direction + 89)))) {
                pShip.direction += 0.25 * pShip.speed * difficultyScale;
              } else {
                pShip.direction -= 0.25 * pShip.speed * difficultyScale;
              }
            } 
        }
        pShip.rotation = pointInDirection(pShip.direction+90); 
      });
    }
    function nearestIsland(sprite) {
      var distance = Infinity;
      var x = 0;
      var y = 0;
      for(let i = 0; i < islands.length; i++) {
        if(getDistance(sprite.x, sprite.y, islands[i].x, islands[i].y) < distance) {
          distance = getDistance(sprite.x, sprite.y, islands[i].x, islands[i].y);
          x = islands[i].x;
          y = islands[i].y;
        }
      }
      return {distance:distance,x:x,y:y};
    }
    function nearestFrigate(sprite) {
      var distance = 10**10;
      var x = 0;
      var y = 0;
      frigates.forEach(function(frigate){
        var currentDist = getDistance(sprite.x,sprite.y,frigate.x,frigate.y);
        if(currentDist < distance) {
          distance = currentDist;
          x = frigate.x;
          y = frigate.y;
        }
      });
      return {distance:distance,x:x,y:y};
    }
    function nearestTreasure(sprite) {
      var distance = 10**10;
      var x = 0;
      var y = 0;
      treasures.forEach(function(treasure){
        var currentDist = getDistance(sprite.x,sprite.y,treasure.x,treasure.y);
        if(currentDist < distance) {
          distance = currentDist;
          x = treasure.x;
          y = treasure.y;
        }
      });
      return {distance:distance,x:x,y:y};
    }
    function handleTreasures(){
      treasures.forEach(function(treasure, i){
        treasure.x = globalX + treasure.myX;
        treasure.y = globalY + treasure.myY;
        treasure.point1 = {x:treasure.x - treasure.width / 8,y:treasure.y - treasure.height / 8};
        treasure.point2 = {x:treasure.x - treasure.width / 8,y:treasure.y + treasure.height / 8};
        treasure.point3 = {x:treasure.x + treasure.width / 8,y:treasure.y + treasure.height / 8};
        treasure.point4 = {x:treasure.x + treasure.width / 8,y:treasure.y - treasure.height / 8};
        treasure.l1 = {p1:treasure.point1,p2:treasure.point2};
        treasure.l2 = {p1:treasure.point2,p2:treasure.point3};
        treasure.l3 = {p1:treasure.point3,p2:treasure.point4};
        treasure.l4 = {p1:treasure.point4,p2:treasure.point1};
        let l = lineCollideLine;
        var collided = false;
        if(l(treasure.l1,ship.l1)||l(treasure.l1,ship.l2)||l(treasure.l1,ship.l3)||l(treasure.l1,ship.l4)) {
          collided = true;
        } else if(l(treasure.l2,ship.l1)||l(treasure.l2,ship.l2)||l(treasure.l2,ship.l3)||l(treasure.l2,ship.l4)) {
          collided = true;
        } else if(l(treasure.l3,ship.l1)||l(treasure.l3,ship.l2)||l(treasure.l3,ship.l3)||l(treasure.l3,ship.l4)) {
          collided = true;
        } else if(l(treasure.l4,ship.l1)||l(treasure.l4,ship.l2)||l(treasure.l4,ship.l3)||l(treasure.l4,ship.l4)) {
          collided = true;
        }
        if(collided) {
          gameScene.removeChild(treasure);
          treasures.splice(i,1)
          --treasuresLeft;
          if(treasuresLeft < 1) {
            state = win;
          }
        }
      });
    }
    function handleShip() {
      if(ship.health < 4) {
        ship.texture = resources["sprites/topDownShiphurt3.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 4),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 7) {
        ship.texture = resources["sprites/topDownShiphurt2.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 10) {
        ship.texture = resources["sprites/topDownShiphurt.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else {
        ship.texture = resources["sprites/topDownShip.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      }
      ship.l1 = {p1:ship.point1,p2:ship.point2};
      ship.l2 = {p1:ship.point2,p2:ship.point3};
      ship.l3 = {p1:ship.point3,p2:ship.point4};
      ship.l4 = {p1:ship.point4,p2:ship.point1};
      explorer.rotation = pointInDirection(ship.direction - 180);
      var data = direction(ship.speed,ship.direction);
      var windOffset = (Math.abs(1-(Math.abs(windDirection - ship.direction)/100)));
      while(windOffset > 1) {
        --windOffset;
      }
      var trueSpeed = Math.round(windSpeed * windOffset);
      var windData = direction(windSpeed * windOffset,windDirection);
      ship.vx = data.r + windData.r;
      ship.vy = data.u + windData.u;
      globalX -= ship.vx;
      globalY -= ship.vy;
      ship.rotation = ((ship.direction + 90) * Math.PI * -1) / 180;
      ship.direction += ship.turn;
      explorer.x = ship.x;
      explorer.y = ship.y;
    }
    function handleIslands() {
      islands.forEach(function(testIsland){
        testIsland.x = globalX + testIsland.myX;
        testIsland.y = globalY + testIsland.myY;
      });
    }
    function handleLoot() {
      barrels.forEach(function(barrel,i){
        barrel.x = globalX + barrel.myX;
        barrel.y = globalY + barrel.myY;
        if(barrel.rotation < 0) {
          barrel.rotation += 0.01;
        } else if (barrel.rotation > 0) {
          barrel.rotation -= 0.01;
        }
        barrel.point1 = {x:barrel.x - barrel.width / 2,y:barrel.y - barrel.height / 2};
        barrel.point2 = {x:barrel.x - barrel.width / 2,y:barrel.y + barrel.height / 2};
        barrel.point3 = {x:barrel.x + barrel.width / 2,y:barrel.y + barrel.height / 2};
        barrel.point4 = {x:barrel.x + barrel.width / 2,y:barrel.y - barrel.height / 2};
        barrel.l1 = {p1:barrel.point1,p2:barrel.point2};
        barrel.l2 = {p1:barrel.point2,p2:barrel.point3};
        barrel.l3 = {p1:barrel.point3,p2:barrel.point4};
        barrel.l4 = {p1:barrel.point4,p2:barrel.point1};
        let l = lineCollideLine;
        var collided = false;
        if(l(barrel.l1,ship.l1)||l(barrel.l1,ship.l2)||l(barrel.l1,ship.l3)||l(barrel.l1,ship.l4)) {
          collided = true;
        } else if(l(barrel.l2,ship.l1)||l(barrel.l2,ship.l2)||l(barrel.l2,ship.l3)||l(barrel.l2,ship.l4)) {
          collided = true;
        } else if(l(barrel.l3,ship.l1)||l(barrel.l3,ship.l2)||l(barrel.l3,ship.l3)||l(barrel.l3,ship.l4)) {
          collided = true;
        } else if(l(barrel.l4,ship.l1)||l(barrel.l4,ship.l2)||l(barrel.l4,ship.l3)||l(barrel.l4,ship.l4)) {
          collided = true;
        }
        if(collided) {
          cannonballs += Math.round(40 / difficultyScale);
          updateHUD();
          gameScene.removeChild(barrel);
          barrels.splice(i, 1);
        }
      });
      timbers.forEach(function(timber,i){
        timber.x = globalX + timber.myX;
        timber.y = globalY + timber.myY;
        if(timber.rotation < 0) {
          timber.rotation += 0.01;
        } else if (timber.rotation > 0) {
          timber.rotation -= 0.01;
        }
        timber.point1 = {x:timber.x - timber.width / 20,y:timber.y - timber.height / 20};
        timber.point2 = {x:timber.x - timber.width / 20,y:timber.y + timber.height / 20};
        timber.point3 = {x:timber.x + timber.width / 20,y:timber.y + timber.height / 20};
        timber.point4 = {x:timber.x + timber.width / 20,y:timber.y - timber.height / 20};
        timber.l1 = {p1:timber.point1,p2:timber.point2};
        timber.l2 = {p1:timber.point2,p2:timber.point3};
        timber.l3 = {p1:timber.point3,p2:timber.point4};
        timber.l4 = {p1:timber.point4,p2:timber.point1};
        let l = lineCollideLine;
        var collided = false;
        if(l(timber.l1,ship.l1)||l(timber.l1,ship.l2)||l(timber.l1,ship.l3)||l(timber.l1,ship.l4)) {
          collided = true;
        } else if(l(timber.l2,ship.l1)||l(timber.l2,ship.l2)||l(timber.l2,ship.l3)||l(timber.l2,ship.l4)) {
          collided = true;
        } else if(l(timber.l3,ship.l1)||l(timber.l3,ship.l2)||l(timber.l3,ship.l3)||l(timber.l3,ship.l4)) {
          collided = true;
        } else if(l(timber.l4,ship.l1)||l(timber.l4,ship.l2)||l(timber.l4,ship.l3)||l(timber.l4,ship.l4)) {
          collided = true;
        }
        if(collided) {
          ship.health += Math.round(10 / difficultyScale);
          updateHUD();
          gameScene.removeChild(timber);
          timbers.splice(i, 1);
        }
      });
    }
    function updateHUD() {
      HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
    }
    function fireCannonballs() {
      if(fireCannon === 2) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        updateHUD();
        fireCannon = false;
      } else if(fireCannon === 1) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        updateHUD();
        fireCannon = false;
      } else if (fireCannon === -1) {
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        updateHUD();
        fireCannon = false;
      }
    }
    function handleDashboard() {
      data = direction(ship.speed,ship.direction);
      windOffset = Math.abs(1-(Math.abs(windDirection - ship.direction)/100));
      while(windOffset > 1) {
        --windOffset;
      }
      windData = direction(windSpeed * windOffset,windDirection);
      var trueVector = findVectorFromImpulse((data.r + windData.r),(data.u + windData.u)*-1)
      arrow.rotation = pointInDirection(trueVector.direction);
      windArrow.rotation = pointInDirection(windDirection-90);
      var nearTreasure = nearestTreasure(ship);
      if(nearTreasure.distance > 10**9) {
        var nearFrigate = nearestFrigate(ship);
        markArrow.rotation = pointInDirection(pointTowards(ship.x,ship.y,nearFrigate.x,nearFrigate.y) - 90);
      } else {
        markArrow.rotation = pointInDirection(pointTowards(ship.x,ship.y,nearTreasure.x,nearTreasure.y)- 90);
      }
      let k = Math.abs(Math.round(trueVector.force));
      // HUD.text = k.toString() + ' ' + windOffset.toString();
      knots.rotation = pointInDirection(90);
      knots2.rotation = pointInDirection(90);
      if(k < 1) {
        knots.visible = false;
        knots2.visible = false;
      }
      if(k < 2) {
        knots.texture = resources["sprites/knot1.png"].texture;
        knots.visible = true;
        knots2.visible = false;
      } else if(k < 3) {
        knots.texture = resources["sprites/knot2.png"].texture;
        knots.visible = true;
        knots2.visible = false;
      } else if(k < 4) {
        knots.texture = resources["sprites/knot3.png"].texture;
        knots.visible = true;
        knots2.visible = false;
      } else if(k < 5) {
        knots.texture = resources["sprites/knot4.png"].texture;
        knots.visible = true;
        knots2.visible = false;
      } else if(k < 6) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots.visible = true;
        knots2.visible = false;
      } else if(k < 7) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots2.texture = resources["sprites/knot1.png"].texture;
        knots2.x = 490;
        knots.visible = true;
        knots2.visible = true;
      } else if(k < 8) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots2.texture = resources["sprites/knot2.png"].texture;
        knots2.x = 505;
        knots.visible = true;
        knots2.visible = true;
      } else if(k < 9) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots2.texture = resources["sprites/knot3.png"].texture;
        knots2.x = 520;
        knots.visible = true;
        knots2.visible = true;
      } else if(k < 10) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots2.texture = resources["sprites/knot4.png"].texture;
        knots2.x = 535;
        knots.visible = true;
        knots2.visible = true;
      } else if(k < 11) {
        knots.texture = resources["sprites/knot5.png"].texture;
        knots2.texture = resources["sprites/knot5.png"].texture;
        knots2.x = 550;
        knots.visible = true;
        knots2.visible = true;
      }
      parseIslandCollision();
      if(divideScale < 2 && shipIntersectingIslands()){
        state = die;
      }
      if(debug){
        drawCollision();
      }
    }
    function win() {
      var textStyle = new PIXI.TextStyle({stroke: "#ffff00",fill:"yellow"})
      winningText = new PIXI.Text("You win!",textStyle);
      winningText.scale.set(10);
      app.stage.addChild(winningText);
      state = wait;
      setTimeout(function() {
      graphics.beginFill(0x000000);
      graphics.alpha = 0;
      graphics.drawRect(0,0,window.innerWidth,window.innerHeight);
      state = dying;
      winningText.visible = false;
      },1000);
    }
    function spawnNewTreasureChest(x,y) {
      let newTreasure = new Sprite(id["treasure.png"]);
      newTreasure.myX = x - globalX;
      newTreasure.myY = y - globalY;
      gameScene.addChild(newTreasure);
      treasures.push(newTreasure);
    }
    function spawnNewCannonballBarrel(x,y,rotation) {
      let barrel = new Sprite(resources["sprites/cannonballbarrel.png"].texture);
      barrel.scale.set(3);
      barrel.myX = x - globalX;
      barrel.myY = y - globalY;
      barrel.rotation = rotation || 0;
      barrels.push(barrel);
      gameScene.addChild(barrel);
    }
    function spawnNewTimberStack(x,y,rotation) {
      let timber = new Sprite(resources["sprites/timber.png"].texture);
      timber.scale.set(3);
      timber.myX = x - globalX;
      timber.myY = y - globalY;
      timber.rotation = rotation || 0;
      timber.anchor.set(0.5);
      timbers.push(timber);
      gameScene.addChild(timber);
    }
    function keyboard(value) {
      let key = {};
      key.value = value;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = event => {
        if (event.key === key.value) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = event => {
        if (event.key === key.value) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      const downListener = key.downHandler.bind(key);
      const upListener = key.upHandler.bind(key);
      
      window.addEventListener(
        "keydown", downListener, false
      );
      window.addEventListener(
        "keyup", upListener, false
      );
      
      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener);
        window.removeEventListener("keyup", upListener);
      };
      
      return key;
    }
  </script>
</body>
</html>