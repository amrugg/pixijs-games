<html>
  <head>
    <link href="favicon.png" type="image/png" rel="icon">
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ship Shooter</title>
</head>
    <style>* {padding: 0; margin: 0}</style>
    <script src="pixi/pixi.min.js"></script>
    <script src="usefulFunctions.js"></script>
    <script src ="bump.js"></script>
<body>
  <script type="text/javascript">
    var BUMP = new Bump(PIXI);
    var params = getParams();
    function getParams() {
      var params = {};
      location.search.substr(1).split("&").forEach(function(el) {
        var data = el.replace(/\+/g, " ").split("=");
        params[decodeURIComponent(data[0])] = data[1] ? decodeURIComponent(data[1]) : true;
      });
      return params;
    }
    var debug = params.debug || false;
    PIXI.utils.skipHello();
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
    let Application = PIXI.Application,
        Container = PIXI.Container,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        TextureCache = PIXI.utils.TextureCache,
        Sprite = PIXI.Sprite,
        Rectangle = PIXI.Rectangle,
        Graphics = PIXI.Graphics;
    let app = new Application({ 
        width: 800,
        height: 800,              
        antialias: true,
        transparent: false,
        resolution: 1
      }
    );
    /// Fill the screen
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    app.renderer.autoResize = true;
    app.renderer.resize(window.innerWidth, window.innerHeight);
    document.body.appendChild(app.view);
    gameScene = new Container();
    var gameScene;
    app.stage.addChild(gameScene);
    var fireCannon = false;
    var files = ["pirateshipblackhurt","pirateshipblackhurt2","pirateshipblackhurt3","cannonball","island","pirateBlob","pirateshipblack","pirateshipred","topDownShip","topDownShipdeath","topDownShiphurt","topDownShiphurt2","topDownShiphurt3"]
    loadArray(files, "sprites", "png");
    loader.add("sprites/treasureHunter.json").load(setup);
    var ship, windSpeed, windDirection;
    var pirateShips = [];
    var cannonballSpeed = 10;
    var cannonballs = 41;
    var HUD = new PIXI.Text("Cannonballs: " + cannonballs.toString() + " Health: " + (10).toString());
    HUD.x = 1000;
    gameScene.addChild(HUD);
    var globalX = -200;
    var globalY = 0;
    var explorer;
    var id, introScene;
    var wPress, sPress;
    var divideScale = params.divideScale || 1;
    var islandPositions = [[-50,10], [-50,85], [100,200], [500,-200], [-500,300], [-410, 210],[-320,120],[-320,30],[-370,-40],[-450, -120]]
    var islands = [];
    var creditsScene;
    var telescopeHole = new PIXI.Graphics();
    var keys = {};
    function setup() {
      telescopeHole.lineStyle(1000*(window.innerWidth/1000),0x000000,1);
      telescopeHole.drawCircle(window.innerWidth/2,window.innerHeight/2,800*(window.innerWidth/1200));
      telescopeHole.endFill();
      telescopeHole.visible = false;
      app.stage.addChild(telescopeHole);
      creditsScene = new PIXI.Container();
      app.stage.addChild(creditsScene);
      creditsScene.visible = false;
      graphics = new PIXI.Graphics();
      id = resources["sprites/treasureHunter.json"].textures;
      spawnNewPirateShip(20);
      /*for(let i = 0; i < randInt(3,7); i++) {
        let testIsland = new Sprite(resources["sprites/island.png"].texture);
        testIsland.myX = randInt(-2500,2500);
        testIsland.myY = randInt(-2500,2500);
        testIsland.scale.set(50, 50);
        islands.push(testIsland)
        gameScene.addChild(testIsland);
      }*/
      ship = new Sprite(resources["sprites/topDownShip.png"].texture);
      ship.scale.x = 10/divideScale;
      ship.scale.y = 10/divideScale;
      gameScene.addChild(ship);
      app.renderer.render(app.stage);
      ship.vx = 0;
      ship.vy = 0;
      ship.x = 750;
      ship.y = 350;
      ship.direction = 89.9999999;
      ship.speed = 0;
      ship.turn = 0;
      ship.health = 10;
      ship.anchor.x = 0.5;
      ship.anchor.y = 0.5;
      explorer = new Sprite(id["explorer.png"]);
      gameScene.addChild(explorer);
      explorer.x = ship.x;
      explorer.y = ship.y;
      for(let i = 0; i < islandPositions.length; i++) {
        let newIsland = new Sprite(resources["sprites/island.png"].texture);
        newIsland.scale.set(50/divideScale);
        newIsland.myX = (islandPositions[i][0] * (10/divideScale)) + 650;
        newIsland.myY = (islandPositions[i][1] * -1 * (10/divideScale)) + 350;
        // console.log(islandPositions[i][0],islandPositions[i][1])
        islands.push(newIsland);
        gameScene.addChild(newIsland);
      }
      gameScene.addChild(graphics);
      var left = keyboard("ArrowLeft"), right = keyboard("ArrowRight"), up = keyboard("ArrowUp"), down = keyboard("ArrowDown");
      var space = keyboard(" "), a = keyboard("a"), d = keyboard("d");
      var enter = keyboard("Enter");
      var s = keyboard("s");
      var w = keyboard("w");
      var b = keyboard("b");
      var t = keyboard("t");
      t.press = () => {
        if(state === sail) {
          state = mountTelescope;
        } else if(state === telescope){
          telescopeHole.visible = false;
          globalX = mountX;
          globalY = mountY;
          ship.x = 750;
          ship.y = 350;
          state = sail;
        }
      }
      wPress = false, sPress = false;
      b.press = () => {
        if(state === sail) {
          
        }
      }
      w.press = () => {
        wPress = true;
      }
      w.release = () => {
        wPress = false;
      }
      s.press = () => {
        sPress = true;
      }
      s.release = () => {
        sPress = false;
      }
      enter.press = () => {
        if(state === intro) {
          introScene.visible = false;
          state = sail;
          gameScene.visible = true;
          app.renderer.backgroundColor = 0x7777FF;
        }
      }
      space.press = () => {
        fireCannon = 2;
      }
      a.press = () => {
        fireCannon = 1;
      }
      d.press = () => {
        fireCannon = -1;
      }
      left.press = () => {
        ship.turn = 1;
        keys.leftPress = true;
      }
      left.release = () => {
        ship.turn = 0;
        keys.leftPress = false;
      };
      right.press = () => {
        ship.turn = -1;
        keys.rightPress = true;
      }
      right.release = () => {
        ship.turn = 0;
        keys.rightPress = false;
      }
      up.press = () => {
        ++ship.speed;
        keys.upPress = true;
      }
      up.release = () => {
        keys.upPress = false;
      }
      down.press = () => {
        if(ship.speed > 0) {
          --ship.speed
        }
        keys.downPress = true;
      }
      down.release = () => {
        keys.downPress = false;
      }
      app.ticker.add(delta => gameLoop(delta));
      windSpeed = 1;
      windDirection = 90;
      setTimeout(changeWind,20000 + randInt(-10000,10000))
    }
    function changeWind() {
      windSpeed = randInt(0,5);
      windDirection = randInt(0,360);
      setTimeout(changeWind,20000 + randInt(-10000,10000));
    }
    var shots = [];
   // var islands = [];
    function spawnNewPirateShip(amount){
      amount = amount || 1;
      for(let i = 0; i < amount; i++) {
        let pirateShip = new Sprite(resources["sprites/pirateshipblack.png"].texture);
        pirateShip.scale.x = 10/divideScale;
        pirateShip.scale.y = 10/divideScale;
        pirateShip.direction = 90;
        pirateShip.speed = 1;
        pirateShip.lastFire = Date.now() - 25000;
        pirateShip.shouldFire = true;
        pirateShip.anchor.set(0.5, 0.5);
        pirateShip.myX = randInt(-5000,2000);
        pirateShip.myY = randInt(-5000,2000);
        pirateShip.hit = false;
        pirateShip.health = 10;
        pirateShip.rotation = pointInDirection(pirateShip.direction + 90);
        pirateShip.pilot = new Sprite(resources["sprites/pirateBlob.png"].texture);
        pirateShip.pilot.x = pirateShip.x;
        pirateShip.pilot.y = pirateShip.y;
        pirateShip.pilot.rotation = pirateShip.rotation;
        pirateShips.push(pirateShip);
        gameScene.addChild(pirateShip);
        gameScene.addChild(pirateShip.pilot);
      }
    }
    function drawCollision(){
      graphics.clear();
      graphics.beginFill(0xFF0000);
      graphics.alpha = 0.5;
      var point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      var point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
      var point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      //var path = [(ship.x - ship.width / 2), (ship.y - ship.height / 2),(ship.x - ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y + ship.height / 2),(ship.x + ship.width / 2), (ship.y - ship.height / 2)]
      //var path = [point1.x,point1.y, point2.x,point2.y,point3.x,point3.y,point4.x,point4.y];
      var path = [ship.l1.p1.x,ship.l1.p1.y,ship.l2.p1.x,ship.l2.p1.y,ship.l3.p1.x,ship.l3.p1.y,ship.l4.p1.x,ship.l4.p1.y,ship.l1.p1.x,ship.l1.p1.y]
      //console.log(path)
      graphics.drawPolygon(path);
      parseIslandCollision();
      islands.forEach(function(island){
        path = [island.p1.x,island.p1.y,island.p2.x,island.p2.y,island.p3.x,island.p3.y,island.p4.x,island.p4.y,island.p5.x,island.p5.y,island.p6.x,island.p6.y,island.p7.x,island.p7.y,island.p8.x,island.p8.y,island.p9.x,island.p9.y,island.p10.x,island.p10.y,island.p11.x,island.p11.y,island.p12.x,island.p12.y,island.p13.x,island.p13.y,island.p14.x,island.p14.y,island.p1.x,island.p1.y];
        //path = [island.l1.p1.x,island.l1.p1.y,island.l2.p1.x,island.l2.p1.y, island.l3.p1.x,island.l3.p1.y, island.l4.p1.x, island.l4.p1.y,island.l5.p1.x,island.l5.p1.y,island.l6.p1.x,island.l6.p1.y,island.l7.p1.x,island.l7.p1.y,island.l8.p1.x,island.l8.p1.y,island.l9.p1.x,island.l9.p1.y,island.l10.p1.x,island.l10.p1.y,island.l11.p1.x,island.l11.p1.y,island.l12.p1.x,island.l12.p1.y,island.l13.p1.x,island.l13.p1.y,island.l14.p1.x,island.l14.p1.y,island.l1.p1.x,island.l1.p1.y];
        graphics.drawPolygon(path);
      })
    }
    function credits(){
      gameScene.visible = false;
      app.renderer.backgroundColor = 0x000000
      creditsScene.visible = true;
      var creditsText = "Thank you for playing Blob Adventures II!\n\n\n\nProgramming done by Aaron Rugg.\n\n\n\nFavicon done by Alexander Rugg.\n\n\n\nBlobs and explorer were found for free by Lanea Zimmerman.\n\n\n\nFavicon and all other graphics were done by Alexander Rugg."
      var style = new PIXI.TextStyle({stroke:"#0000ff", fill:"blue"});
      var creditsMessage = new PIXI.Text(creditsText,style);
      creditsScene.addChild(creditsMessage);
      creditsScene.y = 500;
      state = creditsScroll;
    }
    function creditsScroll() {
      creditsScene.y -= 0.5
    }
    function parseIslandCollision(){
      islands.forEach(function(island) {
        island.p1 = {x:island.x + 75, y: island.y + 25};
        island.p2 = {x:island.x + 410,y: island.y + 25};
        island.p3 = {x:island.x + 550,y:island.y + 125};
        island.p4 = {x:island.x + 625,y:island.y + 200};
        island.p5 = {x:island.x + 625,y:island.y + 300};
        island.p6 = {x:island.x + 775,y:island.y + 475};
        island.p7 = {x:island.x + 925,y:island.y + 475};
        island.p8 = {x:island.x + 925,y:island.y + 675};
        island.p9 = {x:island.x + 725,y:island.y + 675};
        island.p10 = {x:island.x + 725,y:island.y + 625};
        island.p11 = {x:island.x + 500,y:island.y + 625};
        island.p12 = {x:island.x + 300,y:island.y + 525};
        island.p13 = {x: island.x + 150,y:island.y + 525};
        island.p14 = {x: island.x + 50,y:island.y + 100};
        island.l1 = {p1:island.p1,p2:island.p2};
        island.l2 = {p1:island.p2,p2:island.p3};
        island.l3 = {p1:island.p3,p2:island.p4};
        island.l4 = {p1:island.p4,p2:island.p5};
        island.l5 = {p1:island.p5,p2:island.p6};
        island.l6 = {p1:island.p6,p2:island.p7};
        island.l7 = {p1:island.p7,p2:island.p8};
        island.l8 = {p1:island.p8,p2:island.p9};
        island.l9 = {p1:island.p7,p2:island.p10};
        island.l10 = {p1:island.p10,p2:island.p11};
        island.l11 = {p1:island.p11,p2:island.p12};
        island.l12 = {p1:island.p12,p2:island.p13};
        island.l13 = {p1:island.p13,p2:island.p14};
        island.l14 = {p1:island.p14,p2:island.p1};
      })
    }
    var state = introSetup;
    gameScene.visible = true;
    function introSetup(){
      gameScene.visible = false;
      introScene = new Container();
      var introText = 'Press Enter to skip. Press S to speed up. Press W to slow down.\n\n\nHello, brave explorer. We meet again.\n\n\nI assume you are back from Blob Adventures I?\n\n\nWell. You completed that mission well. Almost.\n\n\nI assume you remembered what happened after that?\n\n\nWhat? Is your memory so short? Alright, I will tell you.\n\n\nYou proudly brought in the chests before the king, and then left.\n\n\nWhat happened after that was the king opened them up.\n\n\nAnd then he found that they were stuffed with stinky socks.\n\n\nAt first he suspected you of treason, but then...\n\n\nhe remembered that the blobs use the treasure chests for hampers.\n\n\nThen he sent your superior to get them. He proudly grabbed all the hampers...\n\n\nand then it turned out that the blobs had "hidden" the socks in the hampers.\n\n\nIt seems that the blobs prize the stinky socks as antiques, even more than the treasures.\n\n\nThen the king would have sent you to go retrieve both the chests and the hampers...\n\n\nBut the blobs had moved their treasure overseas.\n\n\nSo, he sends you to swim across the ocean to go retrieve the treasure.\n\n\nFortunately, the queen doubted your swimming abilities and sent you a ship and crew.\n\n\nBeware of the islands while you'+"'"+'re sailing! You may wreck just hitting their sand banks.\n\n\nThe treasure seems to be hoarded by the haughty red sail ships.\n\n\nWell, Godspeed! Oh, right. Sailing the boat. Don'+"'"+"t you just want to wing it?\n\n\nNo? Okay. Up speeds up, down slows down. You can't reverse.\n\n\nLeft and right turn, and space fires a double broadside.\n\n\nOh, and A and D fire the black and gray cannons.\n\n\nT goes into Telescope mode, where you can look about the islands and see things.\n\n\nBut you still might be creamed while you're not looking. Have fun!"
      var style = new PIXI.TextStyle({stroke:"#0000ff", fill:"blue"});
      var introMessage = new PIXI.Text(introText,style);
      app.renderer.backgroundColor = 0x000000;
      introScene.addChild(introMessage);
      app.stage.addChild(introScene);
      introScene.y = 250;
      state = intro;
    }
    function intro(){
      var scroll = 0.5;
      if(sPress) {
        scroll *= 4;
      }
      if(wPress) {
        scroll = 0;
      }
      introScene.y -= scroll;
    }
    function loadArray(array, folder, type){
      /// Loop through the array
      for(let i = 0; i < array.length; i++) {
          /// Make a string that we will change and eventually load with the loader
          let newString = "";
          /// If you give it a folder to load stuff from, so that you don't have to type it all yourself
          if(folder) {
          /// Start with that
          newString += folder;
          if(newString[newString.length - 1] != "/") {
              /// Make sure there's a slash at the end
              newString += "/"
          }
          }
          /// Then add that element
          newString += array[i];
          /// If you want to give it a type and not type that as well
          if(type){
            /// Make sure there's a dot at the end
            if(type[0] != ".") {
                newString += ".";
            }
            /// Add the type
            newString += type;
          }
          /// Load it!
          // Console.log what has been loaded console.log(newString,"has been loaded")
          PIXI.loader.add(newString);
      }
    }
    function gameLoop(delta) {
      state(delta);
    }
    function wait(){

    }
//    var gapLine = {p1:{x:750,y:300},p2:{x:750,y:500}}
    var mountX,mountY;
    function mountTelescope() {
      telescopeHole.visible = true;
      state = telescope;
      // Ship.myX + globalX needs to equal ship.x
      ship.myX = ship.x - globalX;
      ship.myY = ship.y - globalY;
      mountX = globalX;
      mountY = globalY;
    }
    function telescope(){
      if(debug){
        drawCollision();
      }
      if(ship.health < 4) {
        ship.texture = resources["sprites/topDownShiphurt3.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 7) {
        ship.texture = resources["sprites/topDownShiphurt2.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 10) {
        ship.texture = resources["sprites/topDownShiphurt.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else {
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      }
      ship.l1 = {p1:ship.point1,p2:ship.point2};
      ship.l2 = {p1:ship.point2,p2:ship.point3};
      ship.l3 = {p1:ship.point3,p2:ship.point4};
      ship.l4 = {p1:ship.point4,p2:ship.point1};
      handlePirates();
      handleShots();
      islands.forEach(function(testIsland){
        testIsland.x = globalX + testIsland.myX;
        testIsland.y = globalY + testIsland.myY;
      });
      ship.x = ship.myX + globalX;
      ship.y = ship.myY + globalY;
      if(keys.leftPress) {
        globalX += 25;
      }
      if(keys.rightPress) {
        globalX -= 25;
      }
      if(keys.upPress) {
        globalY += 25;
      }
      if(keys.downPress) {
        globalY -= 25;
      }
      explorer.rotation = pointInDirection(ship.direction - 180);
      explorer.x = ship.x;
      explorer.y = ship.y;
    }
    function sail(){
      //  state = wait;
      if(ship.health < 4) {
        ship.texture = resources["sprites/topDownShiphurt3.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 4),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 7) {
        ship.texture = resources["sprites/topDownShiphurt2.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else if (ship.health < 10) {
        ship.texture = resources["sprites/topDownShiphurt.png"].texture;
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      } else {
        ship.point1 = rotatePoint((ship.x - ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point2 = rotatePoint((ship.x - ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point3 = rotatePoint((ship.x + ship.width / 2), (ship.y + ship.height / 2),ship.x,ship.y,ship.rotation);
        ship.point4 = rotatePoint((ship.x + ship.width / 2), (ship.y - ship.height / 2),ship.x,ship.y,ship.rotation);
      }
      explorer.rotation = pointInDirection(ship.direction - 180);
      var data = direction(ship.speed,ship.direction);
      ship.vx = data.r;
      ship.vy = data.u;
      globalX -= ship.vx;
      globalY -= ship.vy;
      islands.forEach(function(testIsland){
        testIsland.x = globalX + testIsland.myX;
        testIsland.y = globalY + testIsland.myY;
      });
      handlePirates();
      handleShots();
      ship.rotation = ((ship.direction + 90) * Math.PI * -1) / 180;
      ship.direction += ship.turn;
      if(fireCannon === 2) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      } else if(fireCannon === 1) {
        if(cannonballs > 0) {
          addNewCannonball(90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      } else if (fireCannon === -1) {
        if(cannonballs > 0) {
          addNewCannonball(-90, 1, ship);
          --cannonballs;
        }
        HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
        fireCannon = false;
      }
      ship.l1 = {p1:ship.point1,p2:ship.point2};
      ship.l2 = {p1:ship.point2,p2:ship.point3};
      ship.l3 = {p1:ship.point3,p2:ship.point4};
      ship.l4 = {p1:ship.point4,p2:ship.point1};
      explorer.x = ship.x
      explorer.y = ship.y
      parseIslandCollision();
      if(divideScale < 2 && shipIntersectingIslands()){
        state = die;
      }
      if(debug){
        drawCollision();
      }
    }
    function shipIntersectingIslands(){
      var v = false;
      var l = lineCollideLine;
      islands.forEach(function(island){
        if(getDistance(island.x,island.y,ship.x,ship.y > 1000)){
          //return;
        }
        /*if(l(ship.l1,island.l1)||l(ship.l1,island.l2)||l(ship.l1,island.l3)||l(ship.l1,island.l4||l(ship.l1,island.l5)||l(ship.l1,island.l6)||l(ship.l1,island.l7)||l(ship.l1,island.l8)||l(ship.l1,island.l9)||l(ship.l1,island.l10)||l(ship.l1,island.l11)||l(ship.l1,island.l12)||l(ship.l1,island.l13)||l(ship.l1,island.l14))){
          v=true;
        }*/
        if(l(ship.l1,island.l1)||l(ship.l1,island.l2)||l(ship.l1,island.l3)||l(ship.l1,island.l4)||l(ship.l1,island.l5)||l(ship.l1,island.l6)){
          v = true;
        }
        if(l(ship.l1,island.l7)||l(ship.l1,island.l8)||l(ship.l1,island.l9)||l(ship.l1,island.l10)||l(ship.l1,island.l11)||l(ship.l1,island.l12)||l(ship.l1,island.l13)||l(ship.l1,island.l14)) {
          v = true;
        }
        if(l(ship.l2,island.l1)||l(ship.l2,island.l2)||l(ship.l2,island.l3)||l(ship.l2,island.l4)||l(ship.l2,island.l5)||l(ship.l2,island.l6)){
          v = true;
        }
        if(l(ship.l2,island.l7)||l(ship.l2,island.l8)||l(ship.l2,island.l9)||l(ship.l2,island.l10)||l(ship.l2,island.l11)||l(ship.l2,island.l12)||l(ship.l2,island.l13)||l(ship.l2,island.l14)) {
          v = true;
        }
        if(l(ship.l3,island.l1)||l(ship.l3,island.l2)||l(ship.l3,island.l3)||l(ship.l3,island.l4)||l(ship.l3,island.l5)||l(ship.l3,island.l6)){
          v = true;
        }
        if(l(ship.l3,island.l7)||l(ship.l3,island.l8)||l(ship.l3,island.l9)||l(ship.l3,island.l10)||l(ship.l3,island.l11)||l(ship.l3,island.l12)||l(ship.l3,island.l13)||l(ship.l3,island.l14)) {
          v = true;
        }
        if(l(ship.l4,island.l1)||l(ship.l4,island.l2)||l(ship.l4,island.l3)||l(ship.l4,island.l4)||l(ship.l4,island.l5)||l(ship.l4,island.l6)){
          v = true;
        }
        if(l(ship.l4,island.l7)||l(ship.l4,island.l8)||l(ship.l4,island.l9)||l(ship.l4,island.l10)||l(ship.l4,island.l11)||l(ship.l4,island.l12)||l(ship.l4,island.l13)||l(ship.l4,island.l14)) {
          v = true;
        }
        /*if(l(ship.l1,island.l2)){
          v = true;
        }
        if(l(ship.l1,island.l3)){
          v = true;
        }
        if(l(ship.l1,island.l4)){
          v = true;
        } */
      }
      );
      return v;
    }
    function die(){
      setTimeout(function() {
      ship.texture = resources["sprites/topDownShipdeath.png"].texture;
      graphics.beginFill(0x000000);
      graphics.alpha = 0;
      graphics.drawRect(0,0,window.innerWidth,window.innerHeight);
      state = dying;
      },1000);
      state = wait;
    }
    function dying(){
      if(graphics.alpha > 0.999){
        state = credits;
      }
      graphics.alpha += 0.01;
    }
    function addNewCannonball(offset, id, launcher) {
      offset = offset || 0;
      let cannonball = new Sprite(resources["sprites/cannonball.png"].texture);
      cannonball.scale.set(5/divideScale,5/divideScale);
      cannonball.speed = cannonballSpeed;
      cannonball.direction = launcher.direction + offset;
      /// The goal of the myX and myY settings are to try to make it appear at the launching ship's position
      /// How do we do that?
      /// The cannonball's X will be set to globalX + myX
      /// So globalX + myX will have to equal the launcher's x
      /// In other words, globalX + myX = launcher.x
      /// Therefore, myX will have to equal launcher.x - globalX
      /// Same for Y
      cannonball.myX = launcher.x - globalX;
      cannonball.myY = launcher.y - globalY;
      cannonball.x = globalX + cannonball.myX;
      cannonball.y = globalY + cannonball.myY;
      cannonball.offset = direction(launcher.speed,launcher.direction);
      cannonball.id = id;
      cannonball.delete = false;
      cannonball.launchTime = Date.now();
      shots.push(cannonball);
      gameScene.addChild(cannonball);
    }
    function handleShots(){
      shots.forEach(function(shot, i){
        if(shot.delete) {
          shot.visible = false;
          gameScene.removeChild(shot);
          shots.splice(i, 1);
          return;
        }
        var newData = direction(shot.speed, shot.direction);
        shot.myX += newData.r + shot.offset.r;
        shot.myY += newData.u + shot.offset.u;
        shot.x = globalX + shot.myX;
        shot.y = globalY + shot.myY;
        if(shot.x < -50 || shot.x > 1450 || shot.y < -50 || shot.y > 1000 && Date.now() - 5000 > shot.launchTime) {
          shot.delete = true;
        }
        pirateShips.forEach(function(pShip){
          if(circleInRectangle([[pShip.point1.x, pShip.point1.y], [pShip.point2.x, pShip.point2.y], [pShip.point3.x, pShip.point3.y],[pShip.point4.x, pShip.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 1) {
            shot.delete = true;
            pShip.hit = true;
          }
        });
        if(circleInRectangle([[ship.point1.x, ship.point1.y], [ship.point2.x, ship.point2.y], [ship.point3.x, ship.point3.y],[ship.point4.x, ship.point4.y]],[shot.x, shot.y],shot.width/2) && shot.id == 0) {
          shot.delete = true;
          --ship.health;
          HUD.text = "Cannonballs: "+cannonballs.toString()+" Health: "+ship.health.toString();
          if(ship.health < 1) {
            state = die;
          }
          if(state === telescope) {
            telescopeHole.visible = false;
            globalX = mountX;
            globalY = mountY;
            ship.x = 750;
            ship.y = 350;
            state = sail;
          }
        }
      });
    }
    function handlePirates(){
      pirateShips.forEach(function(pShip, i){
        if(pShip.health < 4) {
          pShip.texture = resources["sprites/pirateshipblackhurt3.png"].texture;
        } else if (pShip.health < 7) {
          pShip.texture = resources["sprites/pirateshipblackhurt2.png"].texture;
        } else if (pShip.health < 10) {
          pShip.texture = resources["sprites/pirateshipblackhurt.png"].texture;
        }
        if(nearestIsland(pShip) < 300) {
          // console.log(nearestIsland(pShip));
        }
        if(pShip.hit){
          pShip.hit = false;
          --pShip.health;
          if(pShip.health < 1) {
            pShip.visible = false;
            gameScene.removeChild(pShip);
            gameScene.removeChild(pShip.pilot);
            pirateShips.splice(i,1);
            cannonballs += 20;
            ship.health += 5;
            return;
          }
        }
        var badData = direction(pShip.speed, pShip.direction);
        pShip.point1 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point2 = rotatePoint((pShip.x - pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point3 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y + pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        pShip.point4 = rotatePoint((pShip.x + pShip.width / 2), (pShip.y - pShip.height / 2),pShip.x,pShip.y,pShip.rotation);
        if(debug){
       //   drawPirateCollision();
        }
        pShip.vx = badData.r;
        pShip.vy = badData.u;
        pShip.myX += pShip.vx;
        pShip.myY += pShip.vy;
        pShip.x = globalX + pShip.myX;
        pShip.y = globalY + pShip.myY;
        pShip.z = 0;
        pShip.pilot.x = pShip.x;
        pShip.pilot.y = pShip.y;
        pShip.pilot.z = 1;
        var fireRotation1 = pointTowards(pShip.x, pShip.y, ship.x, ship.y);
        var fireRotation2 = pointTowards(pShip.x, pShip.y, ship.x, ship.y) + 180;
        /// Order of priorites:
        /// 1. Flee islands.
        /// 2. Execute a good shot.
        /// 3. Set up a good shot if close enough.
        /// 4. Search for the ship.

        if(nearestIsland(pShip).distance < 2000){
          /// Land ho! Turn away!
          var dangerIsland = nearestIsland(pShip);
          var correctDirection = pointTowards(pShip.x,pShip.y,dangerIsland.x,dangerIsland.y);
          //pShip.direction = correctDirection;
          if(correctDirection < 0) {
            correctDirection += 360;
          } else if (correctDirection > 360) {
            correctDirection -= 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(correctDirection - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.25
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.25
          }
        } else if((Math.abs(fireRotation1-(pShip.direction + 90)) < 20 || Math.abs(fireRotation2-(pShip.direction+90)) < 20)&& pShip.lastFire + 500 < Date.now()) {
          pShip.lastFire = Date.now();
          addNewCannonball(90, 0, pShip);
          addNewCannonball(-90, 0, pShip);
        } else if (getDistance(pShip.x, pShip.y, ship.x, ship.y) > 850 && true) {
          var pointTowardsShip = pointTowards(pShip.x, pShip.y, ship.x, ship.y) - 180;
          if(pointTowardsShip < 0) {
            pointTowardsShip += 360;
          }
          var calcDirection = pShip.direction;
          var turnLeftDistance = 0;
          for(let i = 0; i < 360; i++) {
            calcDirection++;
            if(calcDirection > 359) {
              calcDirection = 0;
            }
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnLeftDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          var turnRightDistance = 0;
          calcDirection = pShip.direction;
          var rightData = [];
          for(let i = 0; i < 360; i++) {
            calcDirection--;
            if(calcDirection < 0) {
              calcDirection = 359;
            }
            rightData.push(calcDirection, pointTowardsShip);
            if(Math.abs(pointTowardsShip - calcDirection)<10) {
              turnRightDistance = i+1;
              calcDirection = pShip.direction;
              break;
            }
          }
          if(turnLeftDistance < turnRightDistance) {
            pShip.direction += 0.25
          } else if (turnRightDistance < turnLeftDistance){
            pShip.direction -= 0.25
          }
        } else {
            if(Math.abs(fireRotation1-(pShip.direction + 90)) < Math.abs(fireRotation2-(pShip.direction+90))) {
              if((Math.abs(fireRotation1-(pShip.direction + 91)) < Math.abs(fireRotation1-(pShip.direction + 89)))) {
                pShip.direction += 0.25;
              } else {
                pShip.direction -= 0.25;
              }
            } else {
              if((Math.abs(fireRotation2-(pShip.direction + 91)) < Math.abs(fireRotation2-(pShip.direction + 89)))) {
                pShip.direction += 0.25;
              } else {
                pShip.direction -= 0.25;
              }
            } 
        }
        pShip.rotation = pointInDirection(pShip.direction+90); 
      });
    }
    function nearestIsland(sprite) {
      var distance = Infinity;
      var x = 0;
      var y = 0;
      for(let i = 0; i < islands.length; i++) {
        if(getDistance(sprite.x, sprite.y, islands[i].x, islands[i].y) < distance) {
          distance = getDistance(sprite.x, sprite.y, islands[i].x, islands[i].y);
          x = islands[i].x;
          y = islands[i].y;
        }
      }
      return {distance:distance,x:x,y:y};
    }
    function keyboard(value) {
      let key = {};
      key.value = value;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = event => {
        if (event.key === key.value) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = event => {
        if (event.key === key.value) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      const downListener = key.downHandler.bind(key);
      const upListener = key.upHandler.bind(key);
      
      window.addEventListener(
        "keydown", downListener, false
      );
      window.addEventListener(
        "keyup", upListener, false
      );
      
      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener);
        window.removeEventListener("keyup", upListener);
      };
      
      return key;
    }
  </script>
</body>
</html>