<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tower Defense</title>
</head>
    <style>* {padding: 0; margin: 0}</style>
    <script src="pixi/pixi.min.js"></script>
    <script src="usefulFunctions.js"></script>
<body style="background-color: black;">
  <script type="text/javascript">
    "use strict";
    
    var params = getParams();
    function getParams() {
      var params = {};
      location.search.substr(1).split("&").forEach(function(el) {
        var data = el.replace(/\+/g, " ").split("=");
        params[decodeURIComponent(data[0])] = data[1] ? decodeURIComponent(data[1]) : true;
      });
      return params;
    }
    PIXI.utils.skipHello();
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
    var Application = PIXI.Application,
        Container = PIXI.Container,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        TextureCache = PIXI.utils.TextureCache,
        Sprite = PIXI.Sprite,
        Rectangle = PIXI.Rectangle,
        Graphics = PIXI.Graphics;
    var canvasLength = Math.min(innerHeight, innerWidth);
    var app = new Application({ 
        width: canvasLength,
        height: canvasLength,
        antialias: true,
        transparent: false,
        resolution: 1
      }
    );
    app.renderer.backgroundColor = 0x55DD55;
    /// Fill the screen 
    app.renderer.view.style.left = (innerWidth - canvasLength)/2 + "px";
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    document.body.appendChild(app.view);
    var scalar = canvasLength/800;
    var canvasOffset = (innerWidth - canvasLength)/2;
    var miscAssets = ["sprites/ground.png", "sprites/tower1.png", "sprites/tower2.png", "sprites/tower3.png", "sprites/coin.png", "sprites/heart.png", "sprites/arrow.png", "sprites/ballista.png", "sprites/rock.png","sprites/cannonball.png"];
    var enemies = ["sprites/enemy.png", "sprites/enemy-armor.png"];
    var tower1Assets = ["damage","fire","pierce","range","speed","tower1-1","tower1-2","tower1-3","twin", "maxSpeed", "maxRange", "maxPower"];
    var tower2Assets = ["damage","range","tower2-1","tower2-2","tower2-3","twin","speed", "golddmg","knockback","cannon"];
    var tower3Assets = ["avalanche","damage","facet","range","tower3-1","tower3-2","twin"];
    loadArray(tower1Assets, "sprites/upgrades/tower1", "png");
    loadArray(tower2Assets, "sprites/upgrades/tower2", "png");
    loadArray(tower3Assets, "sprites/upgrades/tower3", "png");
    loader.add(miscAssets.concat(enemies)).load(setup);
    var state;
    var keys = {};
    var mouseX,mouseY;
    var map = [];
    var path = [];
    var enemies = [];
    var missiles = [];
    var background = new PIXI.Container();
    var foreground = new PIXI.Container();
    var ui = new PIXI.Container();
    app.stage.addChild(background);
    app.stage.addChild(foreground);
    app.stage.addChild(ui);
    ///23563
    ///50931
    ///94163
    ///99047
    ///576
    ///98945
    var randSeed = randInt(1, 100000)
    var level1 = {
        seed: 23522,
        startingSeed: 23522,
        randInt: function(min, max) {
            var x = Math.sin(level1.seed++) * 100000;
            x = x - Math.floor(x);
            return Math.floor(x * (max - min + 1)) + min;
        },
        rand: function(min, max) {
            var x = Math.sin(level1.seed++) * 100000;
            x = x - Math.floor(x);
            return x;
        },
        spawnSeq: [],
        wave: 0,
        curWave: false,
        waveNum: 10,
        levelDiffMin: {
            enemy: {minHealth: 1, maxHealth: 1, minSpeed: -5, maxSpeed: -5, enemyNum: 5, minGold: 0, maxGold: 0, armor: 0},
            "enemy-armor": {minHealth: 1, maxHealth: 1, minSpeed: -5, maxSpeed: -5, enemyNum: 3, minGold: 0, maxGold: 0, armor: 0}
        },
        levelDiffMax: {
            enemy: {minHealth: 2, maxHealth: 2, minSpeed: -7, maxSpeed: -7, enemyNum: 7, minGold: 0, maxGold: 0, armor: 0},
            "enemy-armor": {minHealth: 2, maxHealth: 2, minSpeed: -5, maxSpeed: -5, enemyNum: 4, minGold: 0, maxGold: 0, armor: 0}
        },
        waves: {
            enemy: [{minHealth: 10, maxHealth: 20, minSpeed: 110, maxSpeed: 120, enemyNum: 10, minGold: 1, maxGold: 2, armor: 0}],
            "enemy-armor": [{minHealth: 5, maxHealth: 7, minSpeed: 150, maxSpeed: 170, enemyNum: 3, minGold: 2, maxGold: 3, armor: 3}]
        },
        speed: [1,1,0.9,0.8,0.7,0.6,0.55,0.5,0.75,0.75],
        /// Names of all the enemies
        keys: ["enemy", "enemy-armor"],
        beginWaves: {"enemy": 0, "enemy-armor": 9},
    }
    var towerData = {
        tower1: {range: 200*scalar, dmg: 1, cooldown: 1000, gold:30, pierce:1, aPierce:0, speed:10},
        tower2: {range: 300*scalar, dmg: 3, cooldown: 6000, gold:50, pierce:3, aPierce:1, speed:5},
        tower3: {range: 100*scalar, dmg: 1, cooldown: 900, gold:30, pierce:1, aPierce:0, speed:10},
    }
    var upgradeData = {
        "tower1": {
            upgrades: [
                [
                    {desc: "+1 damage.", cost: 20, texture: "sprites/upgrades/tower1/damage.png", apply: function(tower) {
                        tower.dmg++;
                    }},
                    {desc: "+5 damage.", cost: 50, texture: "sprites/upgrades/tower1/fire.png", apply: function(tower) {
                        tower.dmg += 5;
                    }},
                    {desc: "Final Upgrade:\nSlow firing, +10 damage.", cost: 40, texture: "sprites/upgrades/tower1/maxPower.png", apply: function(tower) {
                        tower.range += 50*scalar;
                        tower.cooldown *= 2;
                        tower.texture = resources["sprites/upgrades/tower1/maxPower.png"].texture;
                    }},
                ],
                [
                    {desc: "+75 range.", cost: 10, texture: "sprites/upgrades/tower1/range.png", apply: function(tower) {
                        tower.range += 75 * scalar;
                    }},
                    {desc: "+1 pierce.", cost: 40, texture: "sprites/upgrades/tower1/pierce.png", apply: function(tower) {
                        tower.aPierce++;
                    }},
                    {desc: "Final Upgrade:\nBetter range and speed.", cost: 40, texture: "sprites/upgrades/tower1/maxRange.png", apply: function(tower) {
                        tower.range += 100*scalar;
                        tower.cooldown /= 1.5;
                        tower.texture = resources["sprites/upgrades/tower1/maxRange.png"].texture;
                    }},
                ],
                [
                    {desc: "Shoots arrows faster.", cost: 20, texture: "sprites/upgrades/tower1/speed.png", apply: function(tower) {
                        tower.cooldown /= 1.5;
                    }},
                    {desc: "Shoots two arrows\nat once.", cost: 50, texture: "sprites/upgrades/tower1/twin.png", apply: function(tower) {
                        tower.doubleArrow = true;
                    }},
                    {desc: "Final Upgrade:\nExtremely fast firing.", cost: 40, texture: "sprites/upgrades/tower1/maxSpeed.png", apply: function(tower) {
                        tower.cooldown /= 3;
                        tower.texture = resources["sprites/upgrades/tower1/maxSpeed.png"].texture;
                    }},
                ]
            ],
            upgradeLevels: ["sprites/upgrades/tower1/tower1-1.png", "sprites/upgrades/tower1/tower1-2.png", "sprites/upgrades/tower1/tower1-3.png"]
        },
        "tower2": {
            upgrades: [
                [
                    {desc: "+2 pierce.", cost: 20, texture: "sprites/upgrades/tower2/damage.png", apply: function(tower) {
                        tower.aPierce += 2;
                        tower.pierce += 2;
                        tower.dmg += 1000;
                    }},
                    {desc: "+3 damage.", cost: 20, texture: "sprites/upgrades/tower2/golddmg.png", apply: function(tower) {
                        tower.dmg += 3;
                    }},
                    {desc: "Final Upgrade:\nCannon shots explode.", cost: 40, texture: "sprites/upgrades/tower2/cannon.png", apply: function(tower) {
                        tower.range += 50*scalar;
                        tower.cooldown *= 2;
                        tower.pierce = 1;
                        tower.dmg += 10;
                        tower.texture = resources["sprites/upgrades/tower2/cannon.png"].texture;
                        tower.cannonball = true;
                    }},
                ],
                [
                    {desc: "+100 range.", cost: 10, texture: "sprites/upgrades/tower2/range.png", apply: function(tower) {
                        tower.range += 100 * scalar;
                    }},
                    {desc: "Bolts slow enemies\ndown slightly.", cost: 10, texture: "sprites/upgrades/tower2/knockback.png", apply: function(tower) {
                        tower.slowdown = 50;
                    }},
                    {desc: "Final upgrade: Shots stun enemies.", cost: 10, texture: "sprites/upgrades/tower2/knockback.png", apply: function(tower) {
                        tower.stun = 75;
                        tower.pierce = 1;
                        tower.range += 200*scalar;
                        tower.cannonball = true;
                    }},
                ],
                [
                    {desc: "Shoots arrows faster.", cost: 20, texture: "sprites/upgrades/tower2/twin.png", apply: function(tower) {
                        tower.cooldown /= 1.5;
                    }},
                    {desc: "Bolts fly faster.", cost: 10, texture: "sprites/upgrades/tower2/speed.png", apply: function(tower) {
                        tower.pierce += 2;
                        tower.speed = 10;
                    }},
                ]
            ],
            upgradeLevels: ["sprites/upgrades/tower2/tower2-1.png", "sprites/upgrades/tower2/tower2-2.png","sprites/upgrades/tower2/tower2-3.png"]
        },
        "tower3": {
            upgrades: [
                [
                    {desc: "+1 damage.", cost: 20, texture: "sprites/upgrades/tower1/damage.png", apply: function(tower) {
                        tower.dmg++;
                    }}
                ],
                [
                    {desc: "+50 range.", cost: 10, texture: "sprites/upgrades/tower1/range.png", apply: function(tower) {
                        tower.range += 100 * scalar;
                    }}
                ],
                [
                    {desc: "Faster firing.", cost: 20, texture: "sprites/upgrades/tower1/twin.png", apply: function(tower) {
                        tower.cooldown /= 1.5;
                    }}
                ]
            ],
            upgradeLevels: ["sprites/upgrades/tower3/tower3-1.png", "sprites/upgrades/tower3/tower3-2.png"]
        }
    }
    var goldCounter = new PIXI.Text("50", new PIXI.TextStyle({fontSize: 30*scalar}));
    var gold = 50000;
    goldCounter.anchor.set(1,0.5);
    ui.addChild(goldCounter);
    goldCounter.y = 25*scalar;
    goldCounter.x = canvasLength - 55*scalar;
    updateGoldText();
    var healthCounter = new PIXI.Text("20", new PIXI.TextStyle({fontSize: 30*scalar}));
    var health = 20;
    healthCounter.anchor.set(0,0.5);
    ui.addChild(healthCounter);
    healthCounter.y = 25*scalar;
    healthCounter.x = 60*scalar;
    updateHealthText();

    var waveCounter = new PIXI.Text("Generate!", new PIXI.TextStyle({fontSize: 30*scalar}));
    waveCounter.anchor.set(1,1);
    waveCounter.x = canvasLength - 20*scalar;
    waveCounter.y = canvasLength - 20*scalar;

    var beginText = new PIXI.Text("Begin!", new PIXI.TextStyle({fontSize: 30*scalar}));
    beginText.anchor.set(0,1);
    beginText.x = 20*scalar;
    beginText.y = canvasLength - 20*scalar;
    ui.addChild(waveCounter);
    ui.addChild(beginText);
    var waveButton = {};
    var towerMenu = [];
    var buildMode = {active: false};
    var upgradeMode = {active: false, menu: []};
    var towers = [];
    var pathLocs = [];
    var textures = {
        tower1: "sprites/tower1.png",
        tower2: "sprites/tower2.png",
        tower3: "sprites/tower3.png",
    }
    var curLevel;
    var rangeGraphics;
    function setup() {
        state = prelude;
        curLevel = level1;
        generateMap(curLevel);
        generateWaves(curLevel);
        // prepWave(curLevel);
        var coin = new Sprite(resources["sprites/coin.png"].texture);
        coin.scale.set(0.75*scalar);
        coin.x = canvasLength - coin.width*1.1;
        coin.y = 5*scalar;
        ui.addChild(coin);
        var heart = new Sprite(resources["sprites/heart.png"].texture);
        heart.scale.set(0.75*scalar);
        heart.x = scalar*5;
        heart.y = 5*scalar;
        ui.addChild(heart);
        var tower1 = new Sprite(resources["sprites/tower1.png"].texture);
        tower1.scale.set(scalar);
        tower1.x = canvasLength - tower1.width * 1.1;
        tower1.y = 100*scalar;
        tower1.cost = 30;
        tower1.type = "tower1";
        ui.addChild(tower1);
        towerMenu.push(tower1);
        var tower2 = new Sprite(resources["sprites/tower2.png"].texture);
        tower2.scale.set(scalar);
        tower2.x = canvasLength - tower2.width * 1.1;
        tower2.y = 200*scalar;
        tower2.cost = 50;
        tower2.type = "tower2";
        ui.addChild(tower2);
        towerMenu.push(tower2);
        var tower3 = new Sprite(resources["sprites/tower3.png"].texture);
        tower3.scale.set(scalar);
        tower3.x = canvasLength - tower3.width * 1.1;
        tower3.y = 300*scalar;
        tower3.cost = 30;
        tower3.type = "tower3";
        ui.addChild(tower3);
        towerMenu.push(tower3);
        buildMode.icon = new Sprite(resources["sprites/tower1.png"].texture);
        ui.addChild(buildMode.icon);
        buildMode.icon.visible = false;
        buildMode.icon.scale.set(scalar);

        rangeGraphics = new PIXI.Graphics();
        rangeGraphics.alpha = 0.5;
        ui.addChild(rangeGraphics);
        upgradeMode.bar = new PIXI.Graphics();
        upgradeMode.bar.beginFill(0xF666666);
        upgradeMode.bar.drawRect(0,canvasLength - 100*scalar, canvasLength, 100*scalar);
        upgradeMode.bar.alpha = 0.8;
        upgradeMode.bar.visible = false;
        ui.addChild(upgradeMode.bar);
        app.ticker.add(delta => gameLoop(delta));
    }
    function generateWaves(level) {
        for(var enI = 0; enI < level.keys.length; enI++) {
            var curLevelDiffMin = level.levelDiffMin[level.keys[enI]];
            var curLevelDiffMax = level.levelDiffMax[level.keys[enI]];
            var waveSet = level.waves[level.keys[enI]];
            var props = Object.keys(curLevelDiffMin);
            for(var i = 1; i < level.waveNum; i++) {
                var nextWave = {};
                for(var prop of props) {
                    if(level.beginWaves[level.keys[enI]] || level.beginWaves[level.keys[enI]] >= i) {
                        nextWave[prop] = waveSet[i-1][prop];
                    } else {
                        nextWave[prop] = waveSet[i-1][prop] + level.randInt(curLevelDiffMin[prop], curLevelDiffMax[prop]);
                    }
                }
                level.waves[level.keys[enI]].push(nextWave);
            }
        }
    }
    function prepWave(level) {
        for(var enI = 0; enI < level.keys.length; enI++) {
            var curWave = level.waves[level.keys[enI]][level.wave];

            var enemyNum = curWave.enemyNum;
            for(var i = 0; i < enemyNum; i++) {
                if(level.beginWaves[level.keys[enI]] <= curLevel.wave) {
                    level.spawnSeq.push({time: Date.now() + i * 1000*curLevel.speed[curLevel.wave] + level.randInt(-500,500)*curLevel.speed[curLevel.wave], type: level.keys[enI]});
                }
            }
        }
        level.spawnSeq.sort(function (a,b) {
            return a.time-b.time;
        })
    }
    function debug() {
        if(press(" ")) {
            play();
        }
    }
    function spawnEnemy(beginX, beginY, level,type) {
        var enemy = new Sprite(resources["sprites/"+type+".png"].texture);
        var waveProps = level.waves[type][level.wave];
        enemy.scale.set(scalar);
        enemy.anchor.set(0.5,0.5);
        enemy.x = (beginX * 80 + 40) * scalar;
        enemy.y = (beginY * 80 + 40) * scalar;
        enemy.targetX = enemy.x;
        enemy.targetY = enemy.y;
        enemy.index = -1;
        enemy.speed = level.randInt(waveProps.minSpeed, waveProps.maxSpeed);
        enemy.chooseNewDir = function () {
            if(++enemy.index >= path.length) {
                health -= 1;
                updateHealthText();
                return -1;
            }
            enemy.dir = path[enemy.index];
            if(enemy.dir === 0) {
                enemy.targetX -= 80*scalar;
            } else if(enemy.dir === 1) {
                enemy.targetX += 80*scalar;   
            } else {
                enemy.targetY += 80*scalar;
            }
            enemy.steps = enemy.speed;
        }
        enemy.chooseNewDir();
        enemy.health = level.randInt(waveProps.minHealth,waveProps.maxHealth);
        enemy.armor = waveProps.armor
        enemy.gold = level.randInt(waveProps.minGold,waveProps.maxGold);
        enemy.advance = 0;
        foreground.addChild(enemy);
        enemies.push(enemy);
        return enemy;
    }
    function generateMap(level) {
        var x = 4;
        var y = -1;
        var generatingPath = true;
        var mem1 = false;
        var mem2 = false;
        path = [];
        pathLocs = [];
        while(generatingPath) {
            var tile = new Sprite(resources["sprites/ground.png"].texture);
            background.addChild(tile);
            tile.x = x * 80 * scalar;
            tile.y = y * 80 * scalar;
            tile.scale.set(scalar);
            map.push(tile);
            pathLocs.push({x:x,y:y});
            do {
                var rand = level1.rand();
                /// 0 for left, 1 for right, 2 for down
                if(path.length < 1) {
                    dir = 2;
                } else {
                    var dir = rand < 0.3 ? 0 : rand < 0.6 ? 1 : 2;
                }
            } while(mem1 === 1-dir || mem2 === 1-dir);
            mem2 = mem1;
            mem1 = dir;
            if(dir === 0) {
                x--;
            } else if(dir === 1) {
                x++;
            } else {
                y++;
            }
            path.push(dir);
            if(x < 0 || x > 7 || y > 9) {
                if(x < 0 || x > 7 || path.length < 15) {
                    return false;
                }
                return true;
            }
        }
    }
    function clearUpdateMenu() {
        upgradeMode.bar.visible = false;
        ui.removeChild(upgradeMode.desc);
        ui.removeChild(upgradeMode.coin);
        ui.removeChild(upgradeMode.costTxt);
        upgradeMode.menu.forEach(function(tower) {
            ui.removeChild(tower);
        })
        rangeGraphics.visible = false;
        waveCounter.visible = true;
    }
    function loadUpdateMenu(tower) {
        var i;
        var len = tower.upgrades.length;
        clearUpdateMenu();
        upgradeMode.bar.visible = true;
        upgradeMode.menu = [];
        for(i = 0; i < len; i++) {
            var curUpgrade = upgradeData[tower.type].upgrades[i][tower.upgrades[i]];
            if(curUpgrade) {
                var upgradeIcon = new Sprite(resources[curUpgrade.texture].texture);
                upgradeIcon.y = canvasLength - 90*scalar;
                // upgradeIcon.anchor.set(0.5,0)
                /// The cutting problem: How far apart would we have to cut len+1 boards out of a board canvasLength long?
                upgradeIcon.x = ((canvasLength- 200*scalar)/(len+1)) * (i+1) - upgradeIcon.width/2;
                upgradeIcon.scale.set(scalar);
                ui.addChild(upgradeIcon);
                upgradeIcon.desc = curUpgrade.desc;
                upgradeIcon.upgrade = curUpgrade.apply;
                upgradeIcon.cost = curUpgrade.cost;
                upgradeIcon.level = tower.upgrades[i];
                upgradeIcon.index = i;
                upgradeMode.menu.push(upgradeIcon);
            }
        }
        waveCounter.visible = false;

        var costTxt = new PIXI.Text("", new PIXI.TextStyle({fontSize: 30*scalar}));
        costTxt.anchor.set(0.5,0.5);
        costTxt.y = canvasLength - 70*scalar;
        costTxt.x = (canvasLength/(len+1))/3;
        ui.addChild(costTxt);
        upgradeMode.costTxt = costTxt;
        var coin = new Sprite(resources["sprites/coin.png"].texture);
        coin.scale.set(0.6*scalar);
        coin.anchor.set(0.5,0.5);
        coin.y = canvasLength - 30*scalar;
        coin.x = (canvasLength/(len+1))/3;
        ui.addChild(coin);
        upgradeMode.coin = coin;

        var desc = new PIXI.Text("", new PIXI.TextStyle({fontSize: 30*scalar}));
        desc.anchor.set(0.5,0.5);
        desc.y = canvasLength - 50*scalar;
        desc.x = (canvasLength/(len+2)) * (i+1);
        ui.addChild(desc);
        upgradeMode.desc = desc;
        upgradeMode.activeTower = tower;
    }
    function gameLoop(delta) {
      state(delta)
    }
    function updateGoldText() {
        goldCounter.text = gold.toString();
    }
    function updateHealthText() {
        healthCounter.text = health.toString();
    }
    function showRange(tower) {
        rangeGraphics.clear();
        rangeGraphics.visible = true;
        rangeGraphics.x = tower.x + tower.width*scalar/2;
        rangeGraphics.y = tower.y + tower.height*scalar/2;
        rangeGraphics.beginFill(0xFFFFFF);
        for(var i = 0; i < 360; i += 15) {
            var vector = direction(tower.range, i);
            rangeGraphics.drawCircle(vector.x,vector.y,10*scalar);
        }
        rangeGraphics.endFill();
    }
    function prelude () {
        if(press("mouse")) {
            if(mouseX > 640*scalar && mouseY > 750*scalar) {
                curLevel.seed = randInt(0,100000);
                curLevel.startingSeed = curLevel.seed;
                do {
                    removeMapChildren();
                    var worked = generateMap(curLevel);
                } while (!worked);
            } else if(mouseX < 110*scalar && mouseY > 750*scalar) {
                ui.removeChild(beginText);
                state = play;
                prepWave(curLevel);
                waveCounter.text = "Wave 1/10";
            }
        } else if(press(" ")) {

            curLevel.seed = randInt(0,100000);
            curLevel.startingSeed = curLevel.seed;
            do {
                removeMapChildren();
                var worked = generateMap(curLevel);
            } while (!worked);
        }
    }
    function removeMapChildren() {
        var i;
        var len = map.length;
        for(i = 0; i < len; ++i) {
            background.removeChild(map[i]);
        }
    }
    function play(){
        handleEnemies();
        if(curLevel.spawnSeq[0]) {
            if(curLevel.spawnSeq[0].time < Date.now()) {
                spawnEnemy(4,-1, curLevel, curLevel.spawnSeq[0].type);
                curLevel.spawnSeq.splice(0,1);
            }
            
        }
        if(enemies.length === 0 && curLevel.spawnSeq.length === 0) {
            waveCounter.text = "Next Wave!";
            if(press(" ") || (keys.mouse && (mouseX > 600*scalar && mouseY > 750*scalar))) {
                ++curLevel.wave;
                prepWave(curLevel);
                waveCounter.text = "Wave " + (curLevel.wave + 1) + "/" + (curLevel.waveNum)
            }
        }
        if(press("q")) {
            state = debug;
        }
        if(press("mouse")) {
            if(buildMode.active) {
                if(mouseX > canvasLength - 160*scalar) {
                    buildMode.active = false;
                    buildMode.icon.visible = false;
                    rangeGraphics.visible = false;
                } else {
                    var buildX = Math.floor(mouseX/(80*scalar));
                    var buildY = Math.floor(mouseY/(80*scalar));
                    if(isClear({x:buildX,y:buildY}) && gold >= towerData[buildMode.building].gold) {
                        buildTower({x:buildX,y:buildY}, buildMode.building);
                        gold -= towerData[buildMode.building].gold;
                        updateGoldText();
                        buildMode.active = false;
                        buildMode.icon.visible = false;
                        rangeGraphics.visible = false;
                    }
                }
            } else if(upgradeMode.active) {
                upgradeMode.menu.forEach(function (icon){
                    if(mouseX > icon.x && mouseX < icon.x + icon.width && mouseY > icon.y && mouseY < icon.y + icon.height) {
                        if(icon.cost <= gold && upgradeMode.activeTower.level === icon.level) {
                            gold -= icon.cost;
                            updateGoldText();
                            icon.upgrade(upgradeMode.activeTower);
                            upgradeMode.activeTower.upgrades[icon.index]++;
                            if (updateTowerUpgrades(upgradeMode.activeTower)) {
                                upgradeMode.activeTower.level++;
                                upgradeMode.activeTower.texture = resources[upgradeData[upgradeMode.activeTower.type].upgradeLevels[upgradeMode.activeTower.level]].texture;
                            }
                            
                        }
                    }
                });

                clearUpdateMenu();
                upgradeMode.active = false;
            } else {
                towerMenu.forEach(function(tower) {
                    if(mouseX > tower.x && mouseX < tower.x + tower.width && mouseY > tower.y && mouseY < tower.y + tower.height && tower.cost <= gold) {
                        buildMode.active = true;
                        buildMode.building = tower.type;
                        buildMode.icon.visible = true;
                        buildMode.icon.texture = resources[textures[tower.type]].texture;
                        buildMode.icon.range = towerData[tower.type].range;
                        showRange(buildMode.icon);
                        rangeGraphics.x = buildMode.icon.x + buildMode.icon.width*scalar/2;
                        rangeGraphics.y = buildMode.icon.y + buildMode.icon.height*scalar/2;
                    }
                });
                if(!buildMode.active) {
                    towers.forEach(function(tower) {
                        if(mouseX > tower.x && mouseX < tower.x + tower.width && mouseY > tower.y && mouseY < tower.y + tower.height) {
                            upgradeMode.active = true;
                            loadUpdateMenu(tower);
                            showRange(tower);
                        }
                    });
                }
            }
        }
        towerMenu.forEach(function(tower) {
            if(tower.cost <= gold) {
                tower.alpha = 1;
            } else {
                tower.alpha = 0.5;
            }
        })
        if(buildMode.active) {
            buildMode.icon.x = Math.floor(mouseX/(80*scalar))*80*scalar;
            buildMode.icon.y = Math.floor(mouseY/(80*scalar))*80*scalar;
            if(mouseX > canvasLength - 160*scalar) {
                buildMode.icon.tint = 0xFF8888;
                rangeGraphics.tint = 0xFF8888;
            } else {
                buildMode.icon.tint = 0xFFFFFF;
                rangeGraphics.tint = 0xFFFFFF;
            }
            rangeGraphics.x = buildMode.icon.x + buildMode.icon.width/2;
            rangeGraphics.y = buildMode.icon.y + buildMode.icon.height/2;
        } else if(upgradeMode.active) {
            var blank = true;
            upgradeMode.menu.forEach(function (icon,i){
                if(mouseX > icon.x && mouseX < icon.x + icon.width && mouseY > icon.y && mouseY < icon.y + icon.height) {
                    upgradeMode.desc.text = icon.desc;
                    upgradeMode.costTxt.text = icon.cost.toString();
                    blank = false;
                }
                if(icon.cost > gold || upgradeMode.activeTower.level !== icon.level) {
                    icon.alpha = 0.5;
                } else {
                    icon.alpha = 1;
                }
            });
            if(blank) {
                upgradeMode.desc.text = "";
                upgradeMode.costTxt.text = "";
            }
        }
        towers.forEach(function(tower) {
            if(tower.type === "tower1") {
                var pivotX = tower.x + 40 * scalar;
                var pivotY = tower.y + 40 * scalar;            
                var target = getBestEnemyWR({x:pivotX, y: pivotY},tower.range);
                if(getDistance(pivotX,pivotY,target.x,target.y) <= tower.range) {
                    if(tower.lastFire + tower.cooldown < Date.now()) {
                        shootMissile(pivotX,pivotY,normalize(target.x - pivotX, target.y - pivotY, tower.speed*scalar), tower.dmg, tower.pierce, tower.aPierce, "arrow", tower.range);
                        if(tower.doubleArrow) {
                            if(tower.secondArrow) {
                                tower.secondArrow = false;
                                tower.lastFire = Date.now();
                            } else {
                                tower.lastFire = Date.now() - tower.cooldown + 100;
                                tower.secondArrow = true;
                            }
                        } else {
                            tower.lastFire = Date.now();
                        }
                    }
                }
            }
            if(tower.type === "tower2") {
                var pivotX = tower.x + 40 * scalar;
                var pivotY = tower.y + 40 * scalar;            
                var target = getBestEnemyWR({x:pivotX, y: pivotY},tower.range);
                if(getDistance(pivotX,pivotY,target.x,target.y) <= tower.range) {
                    if(tower.lastFire + tower.cooldown < Date.now()) {
                        if(tower.cannonball) {
                            var missile = shootMissile(pivotX,pivotY,normalize(target.x - pivotX, target.y - pivotY, tower.speed*scalar), tower.dmg, tower.pierce, tower.aPierce, "cannonball", tower.range);
                            missile.explodes = true;
                        } else {
                            var missile = shootMissile(pivotX,pivotY,normalize(target.x - pivotX, target.y - pivotY, tower.speed*scalar), tower.dmg, tower.pierce, tower.aPierce, "ballista", tower.range);
                        }
                        if(tower.slowdown) {
                            missile.slowdown = tower.slowdown;
                        }
                        if(tower.stun) {
                            missile.stun = tower.stun;
                        }
                        tower.lastFire = Date.now();
                    }
                }
            }
            if(tower.type === "tower3") {
                var pivotX = tower.x + 40 * scalar;
                var pivotY = tower.y + 40 * scalar;            
                var target = getBestEnemyWR({x:pivotX, y: pivotY},tower.range, function(target) {
                    var dx = target.x - pivotX;
                    var dy = target.y - pivotY;
                    if(dy < 0 && Math.abs(dy/dx) > 1) {
                        /// Up
                        if(tower.faces[0] + tower.cooldown < Date.now()) {
                            return true;
                        }
                    }
                    if(dy > 0 && Math.abs(dy/dx) > 1) {
                        /// Down
                        if(tower.faces[1] + tower.cooldown < Date.now()) {
                            return true;
                        }
                    }
                    if(dx < 0 && Math.abs(dx/dy) > 1) {
                        /// Left
                        if(tower.faces[2] + tower.cooldown < Date.now()) {
                            return true;
                        }
                    }
                    if(dx > 0 && Math.abs(dx/dy) > 1) {
                        /// Right
                        if(tower.faces[3] + tower.cooldown < Date.now()) {
                            return true;
                        }
                    }
                });
                if(getDistance(pivotX,pivotY,target.x,target.y) <= tower.range) {
                    shootMissile(pivotX,pivotY,normalize(target.x - pivotX, target.y - pivotY, tower.speed*scalar), tower.dmg, tower.pierce, tower.aPierce, "rock", tower.range);
                    var dx = target.x - pivotX;
                    var dy = target.y - pivotY;
                    if(dy < 0 && Math.abs(dy/dx) > 1) {
                        tower.faces[0] =  Date.now();
                    }
                    if(dy > 0 && Math.abs(dy/dx) > 1) {
                        tower.faces[1] =  Date.now();
                    }
                    if(dx < 0 && Math.abs(dx/dy) > 1) {
                        tower.faces[2] =  Date.now();
                    }
                    if(dx > 0 && Math.abs(dx/dy) > 1) {
                        tower.faces[3] =  Date.now();
                    }
                }
            }
        });
        handleMissiles();
        
    }
    function getBestEnemyWR(pos, range, valid) {
        valid = valid || function() {return true;};
        var i;
        var len = enemies.length;
        var bestAdv = 0;
        var bestMatch = false;
        for(i = 0; i < len; i++) {
            var dist = getDistance(pos.x,pos.y,enemies[i].x,enemies[i].y);
            if(dist < range && enemies[i].advance > bestAdv && valid(enemies[i])) {
                bestAdv = enemies[i].advance;
                bestMatch = enemies[i];
            }
        }
        return bestMatch;
    }
    function handleEnemies() {

        var i;
        var len = enemies.length;
        for(i = 0; i < len; i++) {
            var enemy = enemies[i];
            if(enemy.health <= 0) {
                gold += enemy.gold;
                updateGoldText();
                foreground.removeChild(enemy);
                enemies.splice(i,1);
                --i;
                --len;
                continue;
            }
            if(enemy.stun) {
                enemy.stun--;
            } if(enemy.slowdown) {
                enemy.steps += enemy.slowdown;
                enemy.slowdown = 0;
            } else if(enemy.steps) {
                enemy.x += (enemy.targetX - enemy.x)/enemy.steps;
                enemy.y += (enemy.targetY - enemy.y)/enemy.steps;
                enemy.advance += 1/enemy.speed;
                enemy.steps--;
            } else {
                if(enemy.chooseNewDir() === -1) {
                    foreground.removeChild(enemy);
                    enemies.splice(i,1);
                    --i;
                    --len;
                    continue;
                }
            }
        }
    }
    function updateTowerUpgrades(tower) {
        var maxLevel = Math.max.apply(null,tower.upgrades);
        if(maxLevel === 2) {
            for(var i = 0; i < tower.upgrades.length; i++) {
                if(tower.upgrades[i] !== maxLevel) {
                    tower.upgrades[i] = -1;
                }
            }
            return true;
        } else if(maxLevel === 1) {
            if(tower.upgrades.reduce(function(sum,cur) {return sum+cur}) === 2) {
                for(var i = 0; i < tower.upgrades.length; i++) {
                    if(tower.upgrades[i] !== maxLevel) {
                        tower.upgrades[i] = -1;
                    }
                }
                return true;
            }
            return false;
        }
    }
    function handleMissiles() {
        var i;
        var len = missiles.length;
        for(i = 0; i < len; i++) {
            var missile = missiles[i];
            missile.x += missile.vector.x;
            missile.y += missile.vector.y;
            if(missile.x < - missile.height || missile.x > canvasLength + missile.height || missile.y < - missile.height || missile.y > canvasLength + missile.height || getDistance(missile.x,missile.y,missile.initX, missile.initY) > missile.range) {
                foreground.removeChild(missile);
                missiles.splice(i,1);
                --i;
                --len;
                continue;
            }
            var normVector = normalize(missile.vector.x,missile.vector.y, missile.height/2);
            var missilePoint = {x:normVector.x + missile.x, y: normVector.y + missile.y};
            var target = getClosestEnemy(missilePoint, function(target) {
                if(missile.immune.includes(target)) {
                    return false;
                }
                return true;
            });
                if(getDistance(missilePoint.x, missilePoint.y, target.x, target.y) <= 32*scalar) {
                    target.health -= missile.dmg/Math.max(1,target.armor-missile.aPierce);
                    if(missile.slowdown) {
                        target.slowdown = missile.slowdown;
                    }
                    if(--missile.pierce < 1) {
                        foreground.removeChild(missile);
                        missiles.splice(i,1);
                        --i;
                        --len;
                        if(missile.explodes) {
                            debugger;
                            var targets = getEnemiesWithinRange(missile, 100*scalar);
                            targets.forEach(function (enemy){

                                enemy.health -= missile.dmg/Math.max(1,target.armor-missile.aPierce)/3;
                            });
                        }
                        continue;
                    } else {
                        missile.immune.push(target);
                    }
                }
        }
    }
    function shootMissile(x,y, vector, dmg, pierce, aPierce, type, range) {
        var missile = new Sprite(resources["sprites/" + type + ".png"].texture);
        missile.vector = vector;
        missile.anchor.set(0.5,0.5);
        missile.x = x;
        missile.y = y;
        missile.initX = x;
        missile.initY = y;
        missile.range = range;
        missile.dmg = dmg;
        missile.pierce = pierce;
        missile.aPierce = aPierce;
        missile.immune = [];
        missile.rotation = Math.PI * (-pointTowards(0,0,vector.x,vector.y)) / 180;
        missile.scale.set(scalar);
        foreground.addChild(missile);
        missiles.push(missile);
        return missile;
    }
    function getEnemiesWithinRange(pos, dist,  valid) {
        valid = valid || function() {return true;};
        var i;
        var len = enemies.length;
        var matches = [];
        for(i = 0; i < len; i++) {
            var enDist = getDistance(pos.x,pos.y,enemies[i].x,enemies[i].y);
            if(enDist < dist && valid(enemies[i])) {
                matches.push(enemies[i])
            }
        }
        return matches;
    }
    function getClosestEnemy(pos, valid) {
        valid = valid || function() {return true;};
        var i;
        var len = enemies.length;
        var bestDist = Infinity;
        var bestMatch = false;
        for(i = 0; i < len; i++) {
            var dist = getDistance(pos.x,pos.y,enemies[i].x,enemies[i].y);
            if(dist < bestDist && valid(enemies[i])) {
                bestDist = dist;
                bestMatch = enemies[i];
            }
        }
        return bestMatch;
    }
    function buildTower(pos, type) {
        var tower = new Sprite(resources[textures[type]].texture);
        tower.scale.set(scalar);
        tower.x = pos.x * 80*scalar;
        tower.y = pos.y * 80*scalar;
        tower.buildX = pos.x;
        tower.buildY = pos.y;
        towers.push(tower);
        tower.type = type;
        tower.range = towerData[type].range;
        tower.aPierce = towerData[type].aPierce;
        tower.dmg = towerData[type].dmg;
        tower.level = 0;
        tower.pierce = towerData[type].pierce;
        tower.speed = towerData[type].speed;
        tower.cooldown = towerData[type].cooldown;
        tower.upgrades = [0,0,0];
        if(type === "tower3") {
            tower.faces = [0,0,0,0];
        } else {
            tower.lastFire = 0;
        }

        foreground.addChild(tower);
    }
    function isClear(pos) {
        for(var i = 0; i < pathLocs.length; i++) {
            if(pathLocs[i].x === pos.x && pathLocs[i].y === pos.y) {
                return false;
            }
        }
        i = 0;
        for(i = 0; i < towers.length; i++) {
            if(towers[i].buildX === pos.x && towers[i].buildY === pos.y) {
                return false;
            }
        }
        return true;
    }
    function loadArray(array, folder, type){
    /// Loop through the array
        for(let i = 0; i < array.length; i++) {
            /// Make a string that we will change and eventually load with the loader
            let newString = "";
            /// If you give it a folder to load stuff from, so that you don't have to type it all yourself
            if(folder) {
            /// Start with that
            newString += folder;
            if(newString[newString.length - 1] != "/") {
                /// Make sure there's a slash at the end
                newString += "/"
            }
            }
            /// Then add that element
            newString += array[i];
            /// If you want to give it a type and not type that as well
            if(type){
            /// Make sure there's a dot at the end
            if(type[0] != ".") {
                newString += ".";
            }
            /// Add the type
            newString += type;
            }
            /// Load it!
            PIXI.loader.add(newString);
        }
    }
    function press(key){
        if(keys[key]){
            keys[key] = false;
            return true;
        }
        return false;
    }
    addEventListener("mousedown",function(e){
        if(e.button == 0) {
            keys.mouse = true;
        } else if(e.button == 2) {
            keys.rightMouse = true;
        }
        mouseX = e.pageX - canvasOffset;
        mouseY = e.pageY;
    });
    addEventListener("mouseup",function(e){
        if(e.button == 0) { 
            keys.mouse = false;
        } else if(e.button == 2) {
            keys.rightMouse = false;
        }
    });
    addEventListener("blur", function (){
        keys = {};
    });
    addEventListener("mousemove",function(e){
        mouseX = e.pageX - canvasOffset;
        mouseY = e.pageY;
    });
    addEventListener("keydown", function (e){
        keys[e.key] = true;
    });
    addEventListener("keyup", function (e){
        keys[e.key] = false;
    });
  </script>
</body>
</html>